Makefile:wm97xx-ts-y := wm97xx-core.o
Makefile:wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9705)	+= wm9705.o
Makefile:wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
Makefile:wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
ad7877.c:			 AD7877_POL(ts->stopacq_polarity) |
ad7877.c:			 AD7877_ACQ(ts->acquisition_time) | AD7877_FCD(0);
ad7877.c:	req->xfer[1].delay_usecs = ts->vref_delay_usecs;
ad7877.c:	req->xfer[2].delay_usecs = ts->vref_delay_usecs;
ad7877.c:	req->xfer[4].tx_buf = &ts->cmd_crtl2;	/*REF OFF*/
ad7877.c:	req->xfer[5].tx_buf = &ts->cmd_crtl1;	/*DEFAULT*/
ad7877.c:	struct input_dev *input_dev = ts->input;
ad7877.c:	x = ts->conversion_data[AD7877_SEQ_XPOS] & MAX_12BIT;
ad7877.c:	y = ts->conversion_data[AD7877_SEQ_YPOS] & MAX_12BIT;
ad7877.c:	z1 = ts->conversion_data[AD7877_SEQ_Z1] & MAX_12BIT;
ad7877.c:	z2 = ts->conversion_data[AD7877_SEQ_Z2] & MAX_12BIT;
ad7877.c:		Rt = (z2 - z1) * x * ts->x_plate_ohms;
ad7877.c:		if (Rt > ts->pressure_max)
ad7877.c:		if (!timer_pending(&ts->timer))
ad7877.c:	struct input_dev *input_dev = ts->input;
ad7877.c:	spin_lock_irqsave(&ts->lock, flags);
ad7877.c:	spin_unlock_irqrestore(&ts->lock, flags);
ad7877.c:	error = spi_sync(ts->spi, &ts->msg);
ad7877.c:		dev_err(&ts->spi->dev, "spi_sync --> %d\n", error);
ad7877.c:	spin_lock_irqsave(&ts->lock, flags);
ad7877.c:		mod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);
ad7877.c:	spin_unlock_irqrestore(&ts->lock, flags);
ad7877.c:	mutex_lock(&ts->mutex);
ad7877.c:	if (!ts->disabled) {
ad7877.c:		ts->disabled = true;
ad7877.c:		disable_irq(ts->spi->irq);
ad7877.c:		if (del_timer_sync(&ts->timer))
ad7877.c:	mutex_unlock(&ts->mutex);
ad7877.c:	mutex_lock(&ts->mutex);
ad7877.c:	if (ts->disabled) {
ad7877.c:		ts->disabled = false;
ad7877.c:		enable_irq(ts->spi->irq);
ad7877.c:	mutex_unlock(&ts->mutex);
ad7877.c:	ssize_t v = ad7877_read_adc(ts->spi, \
ad7877.c:	return sprintf(buf, "%u\n", ts->disabled);
ad7877.c:	return sprintf(buf, "%u\n", ts->dac);
ad7877.c:	mutex_lock(&ts->mutex);
ad7877.c:	ts->dac = val & 0xFF;
ad7877.c:	ad7877_write(ts->spi, AD7877_REG_DAC, (ts->dac << 4) | AD7877_DAC_CONF);
ad7877.c:	mutex_unlock(&ts->mutex);
ad7877.c:	return sprintf(buf, "%u\n", ts->gpio3);
ad7877.c:	mutex_lock(&ts->mutex);
ad7877.c:	ts->gpio3 = !!val;
ad7877.c:	ad7877_write(ts->spi, AD7877_REG_EXTWRITE, AD7877_EXTW_GPIO_DATA |
ad7877.c:		 (ts->gpio4 << 4) | (ts->gpio3 << 5));
ad7877.c:	mutex_unlock(&ts->mutex);
ad7877.c:	return sprintf(buf, "%u\n", ts->gpio4);
ad7877.c:	mutex_lock(&ts->mutex);
ad7877.c:	ts->gpio4 = !!val;
ad7877.c:	ad7877_write(ts->spi, AD7877_REG_EXTWRITE, AD7877_EXTW_GPIO_DATA |
ad7877.c:		     (ts->gpio4 << 4) | (ts->gpio3 << 5));
ad7877.c:	mutex_unlock(&ts->mutex);
ad7877.c:	ts->cmd_crtl2 = AD7877_WRITEADD(AD7877_REG_CTRL2) |
ad7877.c:			AD7877_POL(ts->stopacq_polarity) |
ad7877.c:			AD7877_AVG(ts->averaging) | AD7877_PM(1) |
ad7877.c:			AD7877_TMR(ts->pen_down_acc_interval) |
ad7877.c:			AD7877_ACQ(ts->acquisition_time) |
ad7877.c:			AD7877_FCD(ts->first_conversion_delay);
ad7877.c:	ad7877_write(spi, AD7877_REG_CTRL2, ts->cmd_crtl2);
ad7877.c:	ts->cmd_crtl1 = AD7877_WRITEADD(AD7877_REG_CTRL1) |
ad7877.c:	ad7877_write(spi, AD7877_REG_CTRL1, ts->cmd_crtl1);
ad7877.c:	ts->cmd_dummy = 0;
ad7877.c:	m = &ts->msg;
ad7877.c:	ts->xfer[0].tx_buf = &ts->cmd_crtl1;
ad7877.c:	ts->xfer[0].len = 2;
ad7877.c:	ts->xfer[0].cs_change = 1;
ad7877.c:	spi_message_add_tail(&ts->xfer[0], m);
ad7877.c:	ts->xfer[1].tx_buf = &ts->cmd_dummy; /* Send ZERO */
ad7877.c:	ts->xfer[1].len = 2;
ad7877.c:	ts->xfer[1].cs_change = 1;
ad7877.c:	spi_message_add_tail(&ts->xfer[1], m);
ad7877.c:		ts->xfer[i + 2].rx_buf = &ts->conversion_data[AD7877_SEQ_YPOS + i];
ad7877.c:		ts->xfer[i + 2].len = 2;
ad7877.c:			ts->xfer[i + 2].cs_change = 1;
ad7877.c:		spi_message_add_tail(&ts->xfer[i + 2], m);
ad7877.c:	ts->spi = spi;
ad7877.c:	ts->input = input_dev;
ad7877.c:	setup_timer(&ts->timer, ad7877_timer, (unsigned long) ts);
ad7877.c:	mutex_init(&ts->mutex);
ad7877.c:	spin_lock_init(&ts->lock);
ad7877.c:	ts->model = pdata->model ? : 7877;
ad7877.c:	ts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;
ad7877.c:	ts->x_plate_ohms = pdata->x_plate_ohms ? : 400;
ad7877.c:	ts->pressure_max = pdata->pressure_max ? : ~0;
ad7877.c:	ts->stopacq_polarity = pdata->stopacq_polarity;
ad7877.c:	ts->first_conversion_delay = pdata->first_conversion_delay;
ad7877.c:	ts->acquisition_time = pdata->acquisition_time;
ad7877.c:	ts->averaging = pdata->averaging;
ad7877.c:	ts->pen_down_acc_interval = pdata->pen_down_acc_interval;
ad7877.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
ad7877.c:	input_dev->phys = ts->phys;
ad7877.c:	free_irq(ts->spi->irq, ts);
ad7877.c:	input_unregister_device(ts->input);
ad7879.c:	error = regmap_read(ts->regmap, reg, &val);
ad7879.c:		dev_err(ts->dev, "failed to read register %#02x: %d\n",
ad7879.c:	error = regmap_write(ts->regmap, reg, val);
ad7879.c:		dev_err(ts->dev,
ad7879.c:	struct input_dev *input_dev = ts->input;
ad7879.c:	x = ts->conversion_data[AD7879_SEQ_XPOS] & MAX_12BIT;
ad7879.c:	y = ts->conversion_data[AD7879_SEQ_YPOS] & MAX_12BIT;
ad7879.c:	z1 = ts->conversion_data[AD7879_SEQ_Z1] & MAX_12BIT;
ad7879.c:	z2 = ts->conversion_data[AD7879_SEQ_Z2] & MAX_12BIT;
ad7879.c:	if (ts->swap_xy)
ad7879.c:		Rt = (z2 - z1) * x * ts->x_plate_ohms;
ad7879.c:		if (timer_pending(&ts->timer)) {
ad7879.c:			input_report_abs(input_dev, ABS_X, ts->x);
ad7879.c:			input_report_abs(input_dev, ABS_Y, ts->y);
ad7879.c:			input_report_abs(input_dev, ABS_PRESSURE, ts->Rt);
ad7879.c:		ts->x = x;
ad7879.c:		ts->y = y;
ad7879.c:		ts->Rt = Rt;
ad7879.c:	struct input_dev *input_dev = ts->input;
ad7879.c:	regmap_bulk_read(ts->regmap, AD7879_REG_XPLUS,
ad7879.c:			 ts->conversion_data, AD7879_NR_SENSE);
ad7879.c:		mod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);
ad7879.c:	ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);
ad7879.c:	ad7879_write(ts, AD7879_REG_CTRL3, ts->cmd_crtl3);
ad7879.c:	ad7879_write(ts, AD7879_REG_CTRL1, ts->cmd_crtl1);
ad7879.c:	enable_irq(ts->irq);
ad7879.c:	u16 reg = (ts->cmd_crtl2 & ~AD7879_PM(-1)) |
ad7879.c:	disable_irq(ts->irq);
ad7879.c:	if (del_timer_sync(&ts->timer))
ad7879.c:	if (!ts->disabled && !ts->suspended)
ad7879.c:	if (!ts->disabled && !ts->suspended)
ad7879.c:	mutex_lock(&ts->input->mutex);
ad7879.c:	if (!ts->suspended && !ts->disabled && ts->input->users)
ad7879.c:	ts->suspended = true;
ad7879.c:	mutex_unlock(&ts->input->mutex);
ad7879.c:	mutex_lock(&ts->input->mutex);
ad7879.c:	if (ts->suspended && !ts->disabled && ts->input->users)
ad7879.c:	ts->suspended = false;
ad7879.c:	mutex_unlock(&ts->input->mutex);
ad7879.c:	mutex_lock(&ts->input->mutex);
ad7879.c:	if (!ts->suspended && ts->input->users != 0) {
ad7879.c:			if (ts->disabled)
ad7879.c:			if (!ts->disabled)
ad7879.c:	ts->disabled = disable;
ad7879.c:	mutex_unlock(&ts->input->mutex);
ad7879.c:	return sprintf(buf, "%u\n", ts->disabled);
ad7879.c:	mutex_lock(&ts->mutex);
ad7879.c:	ts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIODIR | AD7879_GPIOPOL;
ad7879.c:	err = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);
ad7879.c:	mutex_unlock(&ts->mutex);
ad7879.c:	mutex_lock(&ts->mutex);
ad7879.c:	ts->cmd_crtl2 &= ~AD7879_GPIODIR;
ad7879.c:	ts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIOPOL;
ad7879.c:		ts->cmd_crtl2 |= AD7879_GPIO_DATA;
ad7879.c:		ts->cmd_crtl2 &= ~AD7879_GPIO_DATA;
ad7879.c:	err = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);
ad7879.c:	mutex_unlock(&ts->mutex);
ad7879.c:	mutex_lock(&ts->mutex);
ad7879.c:	mutex_unlock(&ts->mutex);
ad7879.c:	mutex_lock(&ts->mutex);
ad7879.c:		ts->cmd_crtl2 |= AD7879_GPIO_DATA;
ad7879.c:		ts->cmd_crtl2 &= ~AD7879_GPIO_DATA;
ad7879.c:	ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);
ad7879.c:	mutex_unlock(&ts->mutex);
ad7879.c:		gpio_export = device_property_read_bool(ts->dev,
ad7879.c:	mutex_init(&ts->mutex);
ad7879.c:		ts->gc.direction_input = ad7879_gpio_direction_input;
ad7879.c:		ts->gc.direction_output = ad7879_gpio_direction_output;
ad7879.c:		ts->gc.get = ad7879_gpio_get_value;
ad7879.c:		ts->gc.set = ad7879_gpio_set_value;
ad7879.c:		ts->gc.can_sleep = 1;
ad7879.c:		ts->gc.base = gpio_base;
ad7879.c:		ts->gc.ngpio = 1;
ad7879.c:		ts->gc.label = "AD7879-GPIO";
ad7879.c:		ts->gc.owner = THIS_MODULE;
ad7879.c:		ts->gc.parent = ts->dev;
ad7879.c:		ret = devm_gpiochip_add_data(ts->dev, &ts->gc, ts);
ad7879.c:			dev_err(ts->dev, "failed to register gpio %d\n",
ad7879.c:				ts->gc.base);
ad7879.c:	ts->x_plate_ohms = (u16)tmp;
ad7879.c:				&ts->first_conversion_delay);
ad7879.c:				&ts->acquisition_time);
ad7879.c:	device_property_read_u8(dev, "adi,median-filter-size", &ts->median);
ad7879.c:	device_property_read_u8(dev, "adi,averaging", &ts->averaging);
ad7879.c:				&ts->pen_down_acc_interval);
ad7879.c:	ts->swap_xy = device_property_read_bool(dev, "touchscreen-swapped-x-y");
ad7879.c:	sysfs_remove_group(&ts->dev->kobj, &ad7879_attr_group);
ad7879.c:		ts->swap_xy = !pdata->swap_xy;
ad7879.c:		ts->x_plate_ohms = pdata->x_plate_ohms ? : 400;
ad7879.c:		ts->first_conversion_delay = pdata->first_conversion_delay;
ad7879.c:		ts->acquisition_time = pdata->acquisition_time;
ad7879.c:		ts->averaging = pdata->averaging;
ad7879.c:		ts->pen_down_acc_interval = pdata->pen_down_acc_interval;
ad7879.c:		ts->median = pdata->median;
ad7879.c:	ts->dev = dev;
ad7879.c:	ts->input = input_dev;
ad7879.c:	ts->irq = irq;
ad7879.c:	ts->regmap = regmap;
ad7879.c:	setup_timer(&ts->timer, ad7879_timer, (unsigned long) ts);
ad7879.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));
ad7879.c:	input_dev->phys = ts->phys;
ad7879.c:	ts->cmd_crtl3 = AD7879_YPLUS_BIT |
ad7879.c:	ts->cmd_crtl2 = AD7879_PM(AD7879_PM_DYN) | AD7879_DFR |
ad7879.c:			AD7879_AVG(ts->averaging) |
ad7879.c:			AD7879_MFS(ts->median) |
ad7879.c:			AD7879_FCD(ts->first_conversion_delay);
ad7879.c:	ts->cmd_crtl1 = AD7879_MODE_INT | AD7879_MODE_SEQ1 |
ad7879.c:			AD7879_ACQ(ts->acquisition_time) |
ad7879.c:			AD7879_TMR(ts->pen_down_acc_interval);
ad7879.c:	err = devm_request_threaded_irq(dev, ts->irq, NULL, ad7879_irq,
ads7846.c:/* Must be called with ts->lock held */
ads7846.c:	if (!ts->disabled && !ts->suspended) {
ads7846.c:		ts->stopped = true;
ads7846.c:		wake_up(&ts->wait);
ads7846.c:		disable_irq(ts->spi->irq);
ads7846.c:/* Must be called with ts->lock held */
ads7846.c:	if (!ts->disabled && !ts->suspended) {
ads7846.c:		ts->stopped = false;
ads7846.c:		enable_irq(ts->spi->irq);
ads7846.c:/* Must be called with ts->lock held */
ads7846.c:	regulator_disable(ts->reg);
ads7846.c:/* Must be called with ts->lock held */
ads7846.c:	error = regulator_enable(ts->reg);
ads7846.c:		dev_err(&ts->spi->dev, "Failed to enable supply: %d\n", error);
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	if (!ts->disabled) {
ads7846.c:		if  (!ts->suspended)
ads7846.c:		ts->disabled = true;
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	if (ts->disabled) {
ads7846.c:		ts->disabled = false;
ads7846.c:		if (!ts->suspended)
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:	if (ts->use_internal) {
ads7846.c:		req->xfer[1].delay_usecs = ts->vref_delay_usecs;
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:	ssize_t v = ads7846_read12_ser(&ts->spi->dev, \
ads7846.c:	retval *= ts->vref_mv;
ads7846.c:	if (ts->model == 7846)
ads7846.c:	if (ts->model == 7843 && index < 2)	/* in0, in1 */
ads7846.c:	if (ts->model == 7845 && index != 2)	/* in0 */
ads7846.c:	switch (ts->model) {
ads7846.c:		if (!ts->vref_mv) {
ads7846.c:			ts->vref_mv = 2500;
ads7846.c:			ts->use_internal = true;
ads7846.c:		if (!ts->vref_mv) {
ads7846.c:				ts->model);
ads7846.c:	ts->hwmon = hwmon_device_register_with_groups(&spi->dev, spi->modalias,
ads7846.c:	return PTR_ERR_OR_ZERO(ts->hwmon);
ads7846.c:	if (ts->hwmon)
ads7846.c:		hwmon_device_unregister(ts->hwmon);
ads7846.c:	return sprintf(buf, "%u\n", ts->pendown);
ads7846.c:	return sprintf(buf, "%u\n", ts->disabled);
ads7846.c:	if (ts->get_pendown_state)
ads7846.c:		return ts->get_pendown_state();
ads7846.c:	return !gpio_get_value(ts->gpio_pendown);
ads7846.c:	if (!ts->read_cnt || (abs(ts->last_read - *val) > ts->debounce_tol)) {
ads7846.c:		ts->read_rep = 0;
ads7846.c:		if (ts->read_cnt < ts->debounce_max) {
ads7846.c:			ts->last_read = *val;
ads7846.c:			ts->read_cnt++;
ads7846.c:			ts->read_cnt = 0;
ads7846.c:		if (++ts->read_rep > ts->debounce_rep) {
ads7846.c:			ts->read_cnt = 0;
ads7846.c:			ts->read_rep = 0;
ads7846.c:			ts->read_cnt++;
ads7846.c:	if (ts->model == 7845) {
ads7846.c:	struct ads7846_packet *packet = ts->packet;
ads7846.c:	while (msg_idx < ts->msg_count) {
ads7846.c:		ts->wait_for_sync();
ads7846.c:		m = &ts->msg[msg_idx];
ads7846.c:		error = spi_sync(ts->spi, m);
ads7846.c:			dev_err(&ts->spi->dev, "spi_sync --> %d\n", error);
ads7846.c:		if (msg_idx < ts->msg_count - 1) {
ads7846.c:			action = ts->filter(ts->filter_data, msg_idx, &val);
ads7846.c:				msg_idx = ts->msg_count - 1;
ads7846.c:	struct ads7846_packet *packet = ts->packet;
ads7846.c:	if (ts->model == 7845) {
ads7846.c:	if (ts->model == 7843) {
ads7846.c:		Rt = ts->pressure_max / 2;
ads7846.c:	} else if (ts->model == 7845) {
ads7846.c:			Rt = ts->pressure_max / 2;
ads7846.c:		dev_vdbg(&ts->spi->dev, "x/y: %d/%d, PD %d\n", x, y, Rt);
ads7846.c:		Rt *= ts->x_plate_ohms;
ads7846.c:	if (packet->tc.ignore || Rt > ts->pressure_max) {
ads7846.c:		dev_vdbg(&ts->spi->dev, "ignored %d pressure %d\n",
ads7846.c:	if (ts->penirq_recheck_delay_usecs) {
ads7846.c:		udelay(ts->penirq_recheck_delay_usecs);
ads7846.c:		struct input_dev *input = ts->input;
ads7846.c:		if (ts->swap_xy)
ads7846.c:		if (!ts->pendown) {
ads7846.c:			ts->pendown = true;
ads7846.c:			dev_vdbg(&ts->spi->dev, "DOWN\n");
ads7846.c:		input_report_abs(input, ABS_PRESSURE, ts->pressure_max - Rt);
ads7846.c:		dev_vdbg(&ts->spi->dev, "%4d/%4d/%4d\n", x, y, Rt);
ads7846.c:	while (!ts->stopped && get_pendown_state(ts)) {
ads7846.c:		if (!ts->stopped)
ads7846.c:		wait_event_timeout(ts->wait, ts->stopped,
ads7846.c:	if (ts->pendown && !ts->stopped) {
ads7846.c:		struct input_dev *input = ts->input;
ads7846.c:		ts->pendown = false;
ads7846.c:		dev_vdbg(&ts->spi->dev, "UP\n");
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	if (!ts->suspended) {
ads7846.c:		if (!ts->disabled)
ads7846.c:		if (device_may_wakeup(&ts->spi->dev))
ads7846.c:			enable_irq_wake(ts->spi->irq);
ads7846.c:		ts->suspended = true;
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:	mutex_lock(&ts->lock);
ads7846.c:	if (ts->suspended) {
ads7846.c:		ts->suspended = false;
ads7846.c:		if (device_may_wakeup(&ts->spi->dev))
ads7846.c:			disable_irq_wake(ts->spi->irq);
ads7846.c:		if (!ts->disabled)
ads7846.c:	mutex_unlock(&ts->lock);
ads7846.c:		ts->get_pendown_state = pdata->get_pendown_state;
ads7846.c:		ts->gpio_pendown = pdata->gpio_pendown;
ads7846.c:	struct spi_message *m = &ts->msg[0];
ads7846.c:	struct spi_transfer *x = ts->xfer;
ads7846.c:	struct ads7846_packet *packet = ts->packet;
ads7846.c:	if (ts->model == 7873) {
ads7846.c:		ts->model = 7846;
ads7846.c:	ts->msg_count = 1;
ads7846.c:	if (ts->model == 7845) {
ads7846.c:	ts->msg_count++;
ads7846.c:	if (ts->model == 7845) {
ads7846.c:	if (ts->model == 7846) {
ads7846.c:		ts->msg_count++;
ads7846.c:		ts->msg_count++;
ads7846.c:	ts->msg_count++;
ads7846.c:	if (ts->model == 7845) {
ads7846.c:	ts->packet = packet;
ads7846.c:	ts->spi = spi;
ads7846.c:	ts->input = input_dev;
ads7846.c:	mutex_init(&ts->lock);
ads7846.c:	init_waitqueue_head(&ts->wait);
ads7846.c:	ts->model = pdata->model ? : 7846;
ads7846.c:	ts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;
ads7846.c:	ts->x_plate_ohms = pdata->x_plate_ohms ? : 400;
ads7846.c:	ts->pressure_max = pdata->pressure_max ? : ~0;
ads7846.c:	ts->vref_mv = pdata->vref_mv;
ads7846.c:	ts->swap_xy = pdata->swap_xy;
ads7846.c:			err = pdata->filter_init(pdata, &ts->filter_data);
ads7846.c:		ts->filter = pdata->filter;
ads7846.c:		ts->filter_cleanup = pdata->filter_cleanup;
ads7846.c:		ts->debounce_max = pdata->debounce_max;
ads7846.c:		if (ts->debounce_max < 2)
ads7846.c:			ts->debounce_max = 2;
ads7846.c:		ts->debounce_tol = pdata->debounce_tol;
ads7846.c:		ts->debounce_rep = pdata->debounce_rep;
ads7846.c:		ts->filter = ads7846_debounce_filter;
ads7846.c:		ts->filter_data = ts;
ads7846.c:		ts->filter = ads7846_no_filter;
ads7846.c:		ts->penirq_recheck_delay_usecs =
ads7846.c:	ts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;
ads7846.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
ads7846.c:	snprintf(ts->name, sizeof(ts->name), "ADS%d Touchscreen", ts->model);
ads7846.c:	input_dev->name = ts->name;
ads7846.c:	input_dev->phys = ts->phys;
ads7846.c:	ts->reg = regulator_get(&spi->dev, "vcc");
ads7846.c:	if (IS_ERR(ts->reg)) {
ads7846.c:		err = PTR_ERR(ts->reg);
ads7846.c:	err = regulator_enable(ts->reg);
ads7846.c:	if (ts->model == 7845)
ads7846.c:	regulator_disable(ts->reg);
ads7846.c:	regulator_put(ts->reg);
ads7846.c:	if (!ts->get_pendown_state)
ads7846.c:		gpio_free(ts->gpio_pendown);
ads7846.c:	if (ts->filter_cleanup)
ads7846.c:		ts->filter_cleanup(ts->filter_data);
ads7846.c:	free_irq(ts->spi->irq, ts);
ads7846.c:	input_unregister_device(ts->input);
ads7846.c:	regulator_put(ts->reg);
ads7846.c:	if (!ts->get_pendown_state) {
ads7846.c:		gpio_free(ts->gpio_pendown);
ads7846.c:	if (ts->filter_cleanup)
ads7846.c:		ts->filter_cleanup(ts->filter_data);
ads7846.c:	kfree(ts->packet);
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	const struct auo_pixcir_ts_platdata *pdata = ts->pdata;
auo-pixcir-ts.c:	const struct auo_pixcir_ts_platdata *pdata = ts->pdata;
auo-pixcir-ts.c:	while (!ts->stopped) {
auo-pixcir-ts.c:		if (ts->touch_ind_mode) {
auo-pixcir-ts.c:				input_mt_sync(ts->input);
auo-pixcir-ts.c:				input_report_key(ts->input, BTN_TOUCH, 0);
auo-pixcir-ts.c:				input_sync(ts->input);
auo-pixcir-ts.c:			if (!ts->touch_ind_mode)
auo-pixcir-ts.c:			wait_event_timeout(ts->wait, ts->stopped,
auo-pixcir-ts.c:				input_report_abs(ts->input, ABS_MT_POSITION_X,
auo-pixcir-ts.c:				input_report_abs(ts->input, ABS_MT_POSITION_Y,
auo-pixcir-ts.c:				input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,
auo-pixcir-ts.c:				input_report_abs(ts->input, ABS_MT_TOUCH_MINOR,
auo-pixcir-ts.c:				input_report_abs(ts->input, ABS_MT_ORIENTATION,
auo-pixcir-ts.c:				input_mt_sync(ts->input);
auo-pixcir-ts.c:		input_report_key(ts->input, BTN_TOUCH, fingers > 0);
auo-pixcir-ts.c:			input_report_abs(ts->input, ABS_X, point[abs].coord_x);
auo-pixcir-ts.c:			input_report_abs(ts->input, ABS_Y, point[abs].coord_y);
auo-pixcir-ts.c:		input_sync(ts->input);
auo-pixcir-ts.c:		if (!ts->touch_ind_mode)
auo-pixcir-ts.c:		wait_event_timeout(ts->wait, ts->stopped,
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	const struct auo_pixcir_ts_platdata *pdata = ts->pdata;
auo-pixcir-ts.c:	ts->touch_ind_mode = pdata->int_setting == AUO_PIXCIR_INT_TOUCH_IND;
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	ts->stopped = false;
auo-pixcir-ts.c:	struct i2c_client *client = ts->client;
auo-pixcir-ts.c:	ts->stopped = true;
auo-pixcir-ts.c:	wake_up(&ts->wait);
auo-pixcir-ts.c:	struct input_dev *input = ts->input;
auo-pixcir-ts.c:	struct input_dev *input = ts->input;
auo-pixcir-ts.c:	gpio_set_value(ts->pdata->gpio_rst, 0);
auo-pixcir-ts.c:	ts->pdata = pdata;
auo-pixcir-ts.c:	ts->client = client;
auo-pixcir-ts.c:	ts->input = input_dev;
auo-pixcir-ts.c:	ts->touch_ind_mode = 0;
auo-pixcir-ts.c:	ts->stopped = true;
auo-pixcir-ts.c:	init_waitqueue_head(&ts->wait);
auo-pixcir-ts.c:	snprintf(ts->phys, sizeof(ts->phys),
auo-pixcir-ts.c:	input_dev->phys = ts->phys;
auo-pixcir-ts.c:	input_set_drvdata(ts->input, ts);
colibri-vf50-ts.c:	gpiod_set_value(vf50_ts->gpio_ym, 1);
colibri-vf50-ts.c:	pinctrl_pm_select_idle_state(&vf50_ts->pdev->dev);
colibri-vf50-ts.c:	struct device *dev = &vf50_ts->pdev->dev;
colibri-vf50-ts.c:	gpiod_set_value(vf50_ts->gpio_ym, 0);
colibri-vf50-ts.c:	while (!vf50_ts->stop_touchscreen) {
colibri-vf50-ts.c:		val_x = adc_ts_measure(&vf50_ts->channels[0],
colibri-vf50-ts.c:				vf50_ts->gpio_xp, vf50_ts->gpio_xm);
colibri-vf50-ts.c:		val_y = adc_ts_measure(&vf50_ts->channels[1],
colibri-vf50-ts.c:				vf50_ts->gpio_yp, vf50_ts->gpio_ym);
colibri-vf50-ts.c:		val_z1 = adc_ts_measure(&vf50_ts->channels[2],
colibri-vf50-ts.c:				vf50_ts->gpio_yp, vf50_ts->gpio_xm);
colibri-vf50-ts.c:		val_z2 = adc_ts_measure(&vf50_ts->channels[3],
colibri-vf50-ts.c:				vf50_ts->gpio_yp, vf50_ts->gpio_xm);
colibri-vf50-ts.c:		if (val_p < vf50_ts->min_pressure || val_p > 2000)
colibri-vf50-ts.c:			input_report_abs(vf50_ts->ts_input,
colibri-vf50-ts.c:			input_report_abs(vf50_ts->ts_input,
colibri-vf50-ts.c:			input_report_abs(vf50_ts->ts_input,
colibri-vf50-ts.c:			input_report_key(vf50_ts->ts_input, BTN_TOUCH, 1);
colibri-vf50-ts.c:			input_sync(vf50_ts->ts_input);
colibri-vf50-ts.c:	input_report_abs(vf50_ts->ts_input, ABS_PRESSURE, 0);
colibri-vf50-ts.c:	input_report_key(vf50_ts->ts_input, BTN_TOUCH, 0);
colibri-vf50-ts.c:	input_sync(vf50_ts->ts_input);
colibri-vf50-ts.c:	error = of_property_read_u32(dev->of_node, "vf50-ts-min-pressure",
cy8ctma140.c:		slot = input_mt_get_slot_by_key(ts->input, id);
cy8ctma140.c:		dev_dbg(ts->dev, "finger %d: ID %02x (%d, %d) w: %d\n",
cy8ctma140.c:		input_mt_slot(ts->input, slot);
cy8ctma140.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
cy8ctma140.c:		touchscreen_report_pos(ts->input, &ts->props, x, y, true);
cy8ctma140.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, w);
cy8ctma140.c:	input_mt_sync_frame(ts->input);
cy8ctma140.c:	input_sync(ts->input);
cy8ctma140.c:			.addr = ts->client->addr,
cy8ctma140.c:			.addr = ts->client->addr,
cy8ctma140.c:	ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
cy8ctma140.c:			dev_err(ts->dev, "error reading message: %d\n", ret);
cy8ctma140.c:			dev_err(ts->dev, "wrong number of messages\n");
cy8ctma140.c:		dev_dbg(ts->dev, "invalid event\n");
cy8ctma140.c:		dev_err(ts->dev, "unexpected number of fingers: %d\n",
cy8ctma140.c:	ret = i2c_master_send(ts->client, addr, 1);
cy8ctma140.c:		dev_err(ts->dev, "error sending FW info message\n");
cy8ctma140.c:	ret = i2c_master_recv(ts->client, buf, 5);
cy8ctma140.c:		dev_err(ts->dev, "error receiving FW info message\n");
cy8ctma140.c:		dev_err(ts->dev, "got only %d bytes\n", ret);
cy8ctma140.c:	dev_dbg(ts->dev, "vendor %c%c, HW ID %.2d, FW ver %.4d\n",
cy8ctma140.c:	error = regulator_bulk_enable(ARRAY_SIZE(ts->regulators),
cy8ctma140.c:				      ts->regulators);
cy8ctma140.c:		dev_err(ts->dev, "failed to enable regulators\n");
cy8ctma140.c:	regulator_bulk_disable(ARRAY_SIZE(ts->regulators),
cy8ctma140.c:			       ts->regulators);
cy8ctma140.c:	ts->dev = dev;
cy8ctma140.c:	ts->client = client;
cy8ctma140.c:	ts->input = input;
cy8ctma140.c:	touchscreen_parse_properties(input, true, &ts->props);
cy8ctma140.c:	ts->regulators[0].supply = "vcpin";
cy8ctma140.c:	ts->regulators[1].supply = "vdd";
cy8ctma140.c:	error = devm_regulator_bulk_get(dev, ARRAY_SIZE(ts->regulators),
cy8ctma140.c:				      ts->regulators);
cy8ctmg110_ts.c:	if (ts->reset_pin)
cy8ctmg110_ts.c:		gpio_direction_output(ts->reset_pin, 1 - poweron);
cy8ctmg110_ts.c:	ts->client = client;
cy8ctmg110_ts.c:	ts->input = input_dev;
cy8ctmg110_ts.c:	ts->reset_pin = pdata->reset_pin;
cy8ctmg110_ts.c:	ts->irq_pin = pdata->irq_pin;
cy8ctmg110_ts.c:	snprintf(ts->phys, sizeof(ts->phys),
cy8ctmg110_ts.c:	input_dev->phys = ts->phys;
cy8ctmg110_ts.c:	if (ts->reset_pin) {
cy8ctmg110_ts.c:		err = gpio_request(ts->reset_pin, NULL);
cy8ctmg110_ts.c:				ts->reset_pin);
cy8ctmg110_ts.c:	err = gpio_request(ts->irq_pin, "touch_irq_key");
cy8ctmg110_ts.c:			ts->irq_pin, err);
cy8ctmg110_ts.c:	err = gpio_direction_input(ts->irq_pin);
cy8ctmg110_ts.c:			ts->irq_pin, err);
cy8ctmg110_ts.c:	client->irq = gpio_to_irq(ts->irq_pin);
cy8ctmg110_ts.c:			ts->irq_pin, err);
cy8ctmg110_ts.c:	gpio_free(ts->irq_pin);
cy8ctmg110_ts.c:	if (ts->reset_pin)
cy8ctmg110_ts.c:		gpio_free(ts->reset_pin);
cy8ctmg110_ts.c:	input_unregister_device(ts->input);
cy8ctmg110_ts.c:	gpio_free(ts->irq_pin);
cy8ctmg110_ts.c:	if (ts->reset_pin)
cy8ctmg110_ts.c:		gpio_free(ts->reset_pin);
cyttsp4_core.c:			cd->exclusive_waits--;
cyttsp4_core.c:	cd->exclusive_waits--;
cyttsp4_core.h:	return ts->bus_ops->read(ts->dev, ts->xfer_buf, addr, size, buf);
cyttsp4_core.h:	return ts->bus_ops->write(ts->dev, ts->xfer_buf, addr, size, buf);
cyttsp5.c:	error = regmap_bulk_read(ts->regmap, HID_INPUT_REG, temp, sizeof(temp));
cyttsp5.c:	return regmap_bulk_read(ts->regmap, HID_INPUT_REG, buf, size);
cyttsp5.c:	return regmap_bulk_write(ts->regmap, reg & 0xFF, cmd, size + 1);
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	switch (ts->input_buf[2]) {
cyttsp5.c:		tch_addr = ts->input_buf + offset + (i * TOUCH_REPORT_SIZE);
cyttsp5.c:		input_mt_slot(ts->input, t);
cyttsp5.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
cyttsp5.c:		touchscreen_report_pos(ts->input, &ts->prop,
cyttsp5.c:		input_report_abs(ts->input, ABS_MT_PRESSURE,
cyttsp5.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,
cyttsp5.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MINOR,
cyttsp5.c:	ts->num_prv_rec = num_cur_tch;
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:			       ts->input_buf + 3 + si->tch_hdr.ofs,
cyttsp5.c:	if (num_cur_tch == 0 && ts->num_prv_rec == 0)
cyttsp5.c:	input_mt_sync_frame(ts->input);
cyttsp5.c:	input_sync(ts->input);
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, max_x, 0, 0);
cyttsp5.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);
cyttsp5.c:	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, max_p, 0, 0);
cyttsp5.c:	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, MAX_AREA, 0, 0);
cyttsp5.c:	input_set_abs_params(ts->input, ABS_MT_TOUCH_MINOR, 0, MAX_AREA, 0, 0);
cyttsp5.c:	error = input_mt_init_slots(ts->input, si->tch_abs[CY_TCH_T].max,
cyttsp5.c:	error = input_register_device(ts->input);
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	switch (ts->input_buf[2]) {
cyttsp5.c:	if (ts->input_buf[2] != HID_BTN_REPORT_ID)
cyttsp5.c:		cur_btn_state = (ts->input_buf[offset] >> (cur_btn * CY_BITS_PER_BTN))
cyttsp5.c:		input_report_key(ts->input, si->key_code[cur_btn],
cyttsp5.c:		input_sync(ts->input);
cyttsp5.c:	size = get_unaligned_le16(&ts->response_buf[0]);
cyttsp5.c:	report_id = ts->response_buf[HID_OUTPUT_RESPONSE_REPORT_OFFSET];
cyttsp5.c:		if (ts->response_buf[4] != HID_OUTPUT_BL_SOP) {
cyttsp5.c:			dev_err(ts->dev, "HID output response, wrong SOP\n");
cyttsp5.c:		if (ts->response_buf[size - 1] != HID_OUTPUT_BL_EOP) {
cyttsp5.c:			dev_err(ts->dev, "HID output response, wrong EOP\n");
cyttsp5.c:		crc = crc_itu_t(0xFFFF, &ts->response_buf[4], size - 7);
cyttsp5.c:		if (get_unaligned_le16(&ts->response_buf[size - 3]) != crc) {
cyttsp5.c:			dev_err(ts->dev,
cyttsp5.c:		status = ts->response_buf[5];
cyttsp5.c:			dev_err(ts->dev, "HID output response, ERROR:%d\n",
cyttsp5.c:		command_code = ts->response_buf[HID_OUTPUT_RESPONSE_CMD_OFFSET]
cyttsp5.c:			dev_err(ts->dev,
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:	unsigned int btns = ts->response_buf[HID_SYSINFO_BTN_OFFSET] &
cyttsp5.c:	struct cyttsp5_sensing_conf_data *scd = &ts->sysinfo.sensing_conf_data;
cyttsp5.c:		&ts->response_buf[HID_SYSINFO_SENSING_OFFSET];
cyttsp5.c:		dev_err(ts->dev, "Failed to write command %d", rc);
cyttsp5.c:	rc = wait_for_completion_interruptible_timeout(&ts->cmd_done,
cyttsp5.c:		dev_err(ts->dev, "HID output cmd execution timed out\n");
cyttsp5.c:		dev_err(ts->dev, "Validation of the response failed\n");
cyttsp5.c:		dev_err(ts->dev, "Failed to write power command %d", rc);
cyttsp5.c:	rc = wait_for_completion_interruptible_timeout(&ts->cmd_done,
cyttsp5.c:		dev_err(ts->dev, "HID power cmd execution timed out\n");
cyttsp5.c:	if (ts->response_buf[2] != HID_RESPONSE_REPORT_ID ||
cyttsp5.c:	    (ts->response_buf[3] & 0x03) != state ||
cyttsp5.c:	    (ts->response_buf[4] & 0x0f) != HID_CMD_SET_POWER) {
cyttsp5.c:		dev_err(ts->dev, "Validation of the %s response failed\n",
cyttsp5.c:		dev_err(ts->dev, "Failed to write command %d", rc);
cyttsp5.c:	rc = wait_for_completion_interruptible_timeout(&ts->cmd_done,
cyttsp5.c:		dev_err(ts->dev, "HID output cmd execution timed out\n");
cyttsp5.c:		dev_err(ts->dev, "Validation of the response failed\n");
cyttsp5.c:	struct device *dev = ts->dev;
cyttsp5.c:	rc = wait_for_completion_interruptible_timeout(&ts->cmd_done,
cyttsp5.c:		dev_err(ts->dev, "HID get descriptor timed out\n");
cyttsp5.c:	memcpy(desc, ts->response_buf, sizeof(*desc));
cyttsp5.c:	error = cyttsp5_read(ts, ts->input_buf, CY_MAX_INPUT);
cyttsp5.c:	size = get_unaligned_le16(&ts->input_buf[0]);
cyttsp5.c:		report_id = ts->input_buf[2];
cyttsp5.c:		cyttsp5_mt_attention(ts->dev);
cyttsp5.c:		cyttsp5_btn_attention(ts->dev);
cyttsp5.c:		memcpy(ts->response_buf, ts->input_buf, size);
cyttsp5.c:		complete(&ts->cmd_done);
cyttsp5.c:		memcpy(ts->response_buf, ts->input_buf, size);
cyttsp5.c:		complete(&ts->cmd_done);
cyttsp5.c:	error = regmap_bulk_read(ts->regmap, HID_INPUT_REG, buf, sizeof(buf));
cyttsp5.c:	struct cyttsp5_sysinfo *si = &ts->sysinfo;
cyttsp5.c:		dev_err(ts->dev, "Error on deassert int r=%d\n", error);
cyttsp5.c:		dev_err(ts->dev, "Error on launch app r=%d\n", error);
cyttsp5.c:	error = cyttsp5_get_hid_descriptor(ts, &ts->hid_desc);
cyttsp5.c:		dev_err(ts->dev, "Error on getting HID descriptor r=%d\n", error);
cyttsp5.c:		dev_err(ts->dev, "Error on report descriptor r=%d\n", error);
cyttsp5.c:		dev_err(ts->dev, "Error on getting sysinfo r=%d\n", error);
cyttsp5.c:	regulator_disable(ts->vdd);
cyttsp5.c:	ts->regmap = regmap;
cyttsp5.c:	ts->dev = dev;
cyttsp5.c:	si = &ts->sysinfo;
cyttsp5.c:	init_completion(&ts->cmd_done);
cyttsp5.c:	ts->vdd = devm_regulator_get(dev, "vdd");
cyttsp5.c:	if (IS_ERR(ts->vdd)) {
cyttsp5.c:		error = PTR_ERR(ts->vdd);
cyttsp5.c:	error = regulator_enable(ts->vdd);
cyttsp5.c:	ts->input = devm_input_allocate_device(dev);
cyttsp5.c:	if (!ts->input) {
cyttsp5.c:	ts->input->name = "cyttsp5";
cyttsp5.c:	scnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));
cyttsp5.c:	ts->input->phys = ts->phys;
cyttsp5.c:	input_set_drvdata(ts->input, ts);
cyttsp5.c:	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
cyttsp5.c:	if (IS_ERR(ts->reset_gpio)) {
cyttsp5.c:		error = PTR_ERR(ts->reset_gpio);
cyttsp5.c:	gpiod_set_value_cansleep(ts->reset_gpio, 0);
cyttsp5.c:		dev_err(ts->dev, "Fail initial startup r=%d\n", error);
cyttsp5.c:		dev_err(ts->dev, "Error while parsing dts %d\n", error);
cyttsp5.c:	touchscreen_parse_properties(ts->input, true, &ts->prop);
cyttsp5.c:	__set_bit(EV_KEY, ts->input->evbit);
cyttsp5.c:		__set_bit(si->key_code[i], ts->input->keybit);
cyttsp_core.c:		error = ts->bus_ops->read(ts->dev, ts->xfer_buf, command,
cyttsp_core.c:		error = ts->bus_ops->write(ts->dev, ts->xfer_buf, command,
cyttsp_core.c:	if (ts->use_hndshk)
cyttsp_core.c:				ts->xy_data.hst_mode ^ CY_HNDSHK_BIT);
cyttsp_core.c:	memset(&ts->bl_data, 0, sizeof(ts->bl_data));
cyttsp_core.c:	ts->bl_data.bl_status = 0x10;
cyttsp_core.c:				    sizeof(ts->bl_data), &ts->bl_data);
cyttsp_core.c:	if (ts->bl_keys)
cyttsp_core.c:			ts->bl_keys, CY_NUM_BL_KEYS);
cyttsp_core.c:	if (GET_BOOTLOADERMODE(ts->bl_data.bl_status))
cyttsp_core.c:				     sizeof(ts->xy_data), &ts->xy_data);
cyttsp_core.c:	return ts->xy_data.act_dist == CY_ACT_DIST_DFLT ? -EIO : 0;
cyttsp_core.c:	memset(&ts->sysinfo_data, 0, sizeof(ts->sysinfo_data));
cyttsp_core.c:	error = ttsp_read_block_data(ts, CY_REG_BASE, sizeof(ts->sysinfo_data),
cyttsp_core.c:				      &ts->sysinfo_data);
cyttsp_core.c:	if (!ts->sysinfo_data.tts_verh && !ts->sysinfo_data.tts_verl)
cyttsp_core.c:	if (ts->act_intrvl != CY_ACT_INTRVL_DFLT ||
cyttsp_core.c:	    ts->tch_tmout != CY_TCH_TMOUT_DFLT ||
cyttsp_core.c:	    ts->lp_intrvl != CY_LP_INTRVL_DFLT) {
cyttsp_core.c:			ts->act_intrvl,
cyttsp_core.c:			ts->tch_tmout,
cyttsp_core.c:			ts->lp_intrvl
cyttsp_core.c:	if (ts->reset_gpio) {
cyttsp_core.c:		gpiod_set_value_cansleep(ts->reset_gpio, 1);
cyttsp_core.c:		gpiod_set_value_cansleep(ts->reset_gpio, 0);
cyttsp_core.c:	reinit_completion(&ts->bl_ready);
cyttsp_core.c:	ts->state = CY_BL_STATE;
cyttsp_core.c:	enable_irq(ts->irq);
cyttsp_core.c:	timeout = wait_for_completion_timeout(&ts->bl_ready,
cyttsp_core.c:	ts->state = CY_IDLE_STATE;
cyttsp_core.c:	disable_irq(ts->irq);
cyttsp_core.c:	u8 act_dist_setup = ts->act_dist;
cyttsp_core.c:	struct cyttsp_xydata *xy_data = &ts->xy_data;
cyttsp_core.c:	struct input_dev *input = ts->input;
cyttsp_core.c:		dev_dbg(ts->dev, "%s: Large area detected\n", __func__);
cyttsp_core.c:		dev_dbg(ts->dev, "%s: Num touch error detected\n", __func__);
cyttsp_core.c:		dev_dbg(ts->dev, "%s: Invalid buffer detected\n", __func__);
cyttsp_core.c:	if (unlikely(ts->state == CY_BL_STATE)) {
cyttsp_core.c:		complete(&ts->bl_ready);
cyttsp_core.c:				 sizeof(struct cyttsp_xydata), &ts->xy_data);
cyttsp_core.c:	if (unlikely(ts->state == CY_IDLE_STATE))
cyttsp_core.c:	if (GET_BOOTLOADERMODE(ts->xy_data.tt_mode)) {
cyttsp_core.c:			dev_err(ts->dev,
cyttsp_core.c:			ts->state = CY_IDLE_STATE;
cyttsp_core.c:	if (GET_BOOTLOADERMODE(ts->bl_data.bl_status) &&
cyttsp_core.c:	    IS_VALID_APP(ts->bl_data.bl_status)) {
cyttsp_core.c:	if (GET_HSTMODE(ts->bl_data.bl_file) != CY_OPERATE_MODE ||
cyttsp_core.c:	    IS_OPERATIONAL_ERR(ts->bl_data.bl_status)) {
cyttsp_core.c:	ts->state = CY_ACTIVE_STATE;
cyttsp_core.c:				     sizeof(ts->xy_data), &ts->xy_data);
cyttsp_core.c:	if (GET_HSTMODE(ts->xy_data.hst_mode))
cyttsp_core.c:	enable_irq(ts->irq);
cyttsp_core.c:	disable_irq(ts->irq);
cyttsp_core.c:	mutex_lock(&ts->input->mutex);
cyttsp_core.c:	if (ts->input->users) {
cyttsp_core.c:			ts->suspended = true;
cyttsp_core.c:	mutex_unlock(&ts->input->mutex);
cyttsp_core.c:	mutex_lock(&ts->input->mutex);
cyttsp_core.c:	if (ts->input->users)
cyttsp_core.c:	ts->suspended = false;
cyttsp_core.c:	mutex_unlock(&ts->input->mutex);
cyttsp_core.c:	if (!ts->suspended)
cyttsp_core.c:	if (!ts->suspended)
cyttsp_core.c:	struct device *dev = ts->dev;
cyttsp_core.c:	ts->bl_keys = devm_kzalloc(dev, CY_NUM_BL_KEYS, GFP_KERNEL);
cyttsp_core.c:	if (!ts->bl_keys)
cyttsp_core.c:	ts->use_hndshk = false;
cyttsp_core.c:	ts->act_dist = CY_ACT_DIST_DFLT;
cyttsp_core.c:	ts->act_intrvl = CY_ACT_INTRVL_DFLT;
cyttsp_core.c:	ts->tch_tmout = CY_TCH_TMOUT_DFLT;
cyttsp_core.c:	ts->lp_intrvl = CY_LP_INTRVL_DFLT;
cyttsp_core.c:					    ts->bl_keys, CY_NUM_BL_KEYS);
cyttsp_core.c:	ts->use_hndshk = device_property_present(dev, "use-handshake");
cyttsp_core.c:		ts->act_dist &= ~CY_ACT_DIST_MASK;
cyttsp_core.c:		ts->act_dist |= dt_value;
cyttsp_core.c:		ts->act_intrvl = dt_value;
cyttsp_core.c:		ts->lp_intrvl = dt_value / 10;
cyttsp_core.c:		ts->tch_tmout = dt_value / 10;
cyttsp_core.c:	ts->dev = dev;
cyttsp_core.c:	ts->input = input_dev;
cyttsp_core.c:	ts->bus_ops = bus_ops;
cyttsp_core.c:	ts->irq = irq;
cyttsp_core.c:	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
cyttsp_core.c:	if (IS_ERR(ts->reset_gpio)) {
cyttsp_core.c:		error = PTR_ERR(ts->reset_gpio);
cyttsp_core.c:	init_completion(&ts->bl_ready);
cyttsp_core.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));
cyttsp_core.c:	input_dev->phys = ts->phys;
cyttsp_core.c:	input_dev->dev.parent = ts->dev;
cyttsp_core.c:	error = devm_request_threaded_irq(dev, ts->irq, NULL, cyttsp_irq,
cyttsp_core.c:		dev_err(ts->dev, "failed to request IRQ %d, err: %d\n",
cyttsp_core.c:			ts->irq, error);
cyttsp_core.c:	disable_irq(ts->irq);
cyttsp_core.c:		dev_err(ts->dev, "failed to register input device: %d\n",
egalax_ts.c:	struct input_dev *input_dev = ts->input_dev;
egalax_ts.c:	struct i2c_client *client = ts->client;
egalax_ts.c:	ts->client = client;
egalax_ts.c:	ts->input_dev = input_dev;
egalax_ts.c:	error = input_register_device(ts->input_dev);
ektf2127.c:		dev_err(&ts->client->dev,
ektf2127.c:	input_mt_assign_slots(ts->input, slots, touches,
ektf2127.c:		input_mt_slot(ts->input, slots[i]);
ektf2127.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
ektf2127.c:		touchscreen_report_pos(ts->input, &ts->prop,
ektf2127.c:	input_mt_sync_frame(ts->input);
ektf2127.c:	input_sync(ts->input);
ektf2127.c:	struct device *dev = &ts->client->dev;
ektf2127.c:	ret = i2c_master_recv(ts->client, buf, EKTF2127_TOUCH_REPORT_SIZE);
ektf2127.c:	enable_irq(ts->client->irq);
ektf2127.c:	gpiod_set_value_cansleep(ts->power_gpios, 1);
ektf2127.c:	disable_irq(ts->client->irq);
ektf2127.c:	gpiod_set_value_cansleep(ts->power_gpios, 0);
ektf2127.c:	mutex_lock(&ts->input->mutex);
ektf2127.c:	if (ts->input->users)
ektf2127.c:		ektf2127_stop(ts->input);
ektf2127.c:	mutex_unlock(&ts->input->mutex);
ektf2127.c:	mutex_lock(&ts->input->mutex);
ektf2127.c:	if (ts->input->users)
ektf2127.c:		ektf2127_start(ts->input);
ektf2127.c:	mutex_unlock(&ts->input->mutex);
ektf2127.c:	ts->power_gpios = devm_gpiod_get(dev, "power", GPIOD_OUT_HIGH);
ektf2127.c:	if (IS_ERR(ts->power_gpios)) {
ektf2127.c:		error = PTR_ERR(ts->power_gpios);
ektf2127.c:	ts->client = client;
ektf2127.c:	i2c_master_recv(ts->client, buf, sizeof(buf));
ektf2127.c:	touchscreen_parse_properties(input, true, &ts->prop);
ektf2127.c:	ts->input = input;
ektf2127.c:	ektf2127_stop(ts->input);
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:	ts->state = ELAN_WAIT_RECALIBRATION;
elants_i2c.c:	reinit_completion(&ts->cmd_done);
elants_i2c.c:	ret = wait_for_completion_interruptible_timeout(&ts->cmd_done,
elants_i2c.c:	ts->state = ELAN_STATE_NORMAL;
elants_i2c.c:	if (memcmp(rek_resp, ts->cmd_resp, sizeof(rek_resp))) {
elants_i2c.c:			(int)sizeof(ts->cmd_resp), ts->cmd_resp);
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:			ts->hw_version = elants_i2c_parse_version(resp);
elants_i2c.c:			if (ts->hw_version != 0xffff)
elants_i2c.c:	dev_err(&client->dev, "Invalid fw id: %#04x\n", ts->hw_version);
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:			ts->fw_version = elants_i2c_parse_version(resp);
elants_i2c.c:			if (ts->fw_version != 0x0000 &&
elants_i2c.c:			    ts->fw_version != 0xffff)
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:			ts->test_version = version >> 8;
elants_i2c.c:			ts->solution_version = version & 0xff;
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:	ts->bc_version = version >> 8;
elants_i2c.c:	ts->iap_version = version & 0xff;
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:		ts->x_max = ELAN_TS_RESOLUTION(rows, osr);
elants_i2c.c:		ts->x_res = DIV_ROUND_CLOSEST(ts->x_max, phy_x);
elants_i2c.c:		ts->y_max = ELAN_TS_RESOLUTION(cols, osr);
elants_i2c.c:		ts->y_res = DIV_ROUND_CLOSEST(ts->y_max, phy_y);
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:			ts->iap_mode = ELAN_IAP_OPERATIONAL;
elants_i2c.c:		ts->iap_mode = ELAN_IAP_RECOVERY;
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:	fw_name = kasprintf(GFP_KERNEL, "elants_i2c_%04x.bin", ts->hw_version);
elants_i2c.c:					ts->iap_mode == ELAN_IAP_RECOVERY);
elants_i2c.c:		ts->iap_mode = ELAN_IAP_RECOVERY;
elants_i2c.c:		ts->iap_mode = ELAN_IAP_RECOVERY;
elants_i2c.c:	ts->iap_mode = ELAN_IAP_OPERATIONAL;
elants_i2c.c:	ts->state = ELAN_STATE_NORMAL;
elants_i2c.c:	struct input_dev *input = ts->input;
elants_i2c.c:	dev_dbg(&ts->client->dev,
elants_i2c.c:			dev_dbg(&ts->client->dev, "i=%d x=%d y=%d p=%d w=%d\n",
elants_i2c.c:		dev_warn(&ts->client->dev,
elants_i2c.c:		dev_warn(&ts->client->dev,
elants_i2c.c:	struct i2c_client *client = ts->client;
elants_i2c.c:	len = i2c_master_recv(client, ts->buf, sizeof(ts->buf));
elants_i2c.c:		__func__, HEADER_SIZE, ts->buf);
elants_i2c.c:	switch (ts->state) {
elants_i2c.c:		if (ts->buf[FW_HDR_TYPE] == CMD_HEADER_REK) {
elants_i2c.c:			memcpy(ts->cmd_resp, ts->buf, sizeof(ts->cmd_resp));
elants_i2c.c:			complete(&ts->cmd_done);
elants_i2c.c:			ts->state = ELAN_STATE_NORMAL;
elants_i2c.c:		if (ts->buf[FW_HDR_TYPE] != QUEUE_HEADER_NORMAL)
elants_i2c.c:		ts->state = ELAN_STATE_NORMAL;
elants_i2c.c:		switch (ts->buf[FW_HDR_TYPE]) {
elants_i2c.c:			if (memcmp(ts->buf, wait_packet, sizeof(wait_packet))) {
elants_i2c.c:					HEADER_SIZE, ts->buf);
elants_i2c.c:				ts->state = ELAN_WAIT_QUEUE_HEADER;
elants_i2c.c:			elants_i2c_event(ts, &ts->buf[HEADER_SIZE]);
elants_i2c.c:			report_count = ts->buf[FW_HDR_COUNT];
elants_i2c.c:					HEADER_SIZE, ts->buf);
elants_i2c.c:			report_len = ts->buf[FW_HDR_LENGTH] / report_count;
elants_i2c.c:					HEADER_SIZE, ts->buf);
elants_i2c.c:				u8 *buf = ts->buf + HEADER_SIZE +
elants_i2c.c:				HEADER_SIZE, ts->buf);
elants_i2c.c:	error = mutex_lock_interruptible(&ts->sysfs_mutex);
elants_i2c.c:	mutex_unlock(&ts->sysfs_mutex);
elants_i2c.c:	error = mutex_lock_interruptible(&ts->sysfs_mutex);
elants_i2c.c:	mutex_unlock(&ts->sysfs_mutex);
elants_i2c.c:		       ts->iap_mode == ELAN_IAP_OPERATIONAL ?
elants_i2c.c:	sysfs_remove_group(&ts->client->dev.kobj, &elants_attribute_group);
elants_i2c.c:	if (IS_ERR_OR_NULL(ts->reset_gpio))
elants_i2c.c:	gpiod_set_value_cansleep(ts->reset_gpio, 1);
elants_i2c.c:	error = regulator_enable(ts->vcc33);
elants_i2c.c:		dev_err(&ts->client->dev,
elants_i2c.c:	error = regulator_enable(ts->vccio);
elants_i2c.c:		dev_err(&ts->client->dev,
elants_i2c.c:		regulator_disable(ts->vcc33);
elants_i2c.c:	gpiod_set_value_cansleep(ts->reset_gpio, 0);
elants_i2c.c:	if (!IS_ERR_OR_NULL(ts->reset_gpio)) {
elants_i2c.c:		gpiod_set_value_cansleep(ts->reset_gpio, 1);
elants_i2c.c:		regulator_disable(ts->vccio);
elants_i2c.c:		regulator_disable(ts->vcc33);
elants_i2c.c:	mutex_init(&ts->sysfs_mutex);
elants_i2c.c:	init_completion(&ts->cmd_done);
elants_i2c.c:	ts->client = client;
elants_i2c.c:	ts->vcc33 = devm_regulator_get(&client->dev, "vcc33");
elants_i2c.c:	if (IS_ERR(ts->vcc33)) {
elants_i2c.c:		error = PTR_ERR(ts->vcc33);
elants_i2c.c:	ts->vccio = devm_regulator_get(&client->dev, "vccio");
elants_i2c.c:	if (IS_ERR(ts->vccio)) {
elants_i2c.c:		error = PTR_ERR(ts->vccio);
elants_i2c.c:	ts->reset_gpio = devm_gpiod_get(&client->dev, "reset", GPIOD_OUT_LOW);
elants_i2c.c:	if (IS_ERR(ts->reset_gpio)) {
elants_i2c.c:		error = PTR_ERR(ts->reset_gpio);
elants_i2c.c:		ts->keep_power_in_suspend = true;
elants_i2c.c:	ts->input = devm_input_allocate_device(&client->dev);
elants_i2c.c:	if (!ts->input) {
elants_i2c.c:	ts->input->name = "Elan Touchscreen";
elants_i2c.c:	ts->input->id.bustype = BUS_I2C;
elants_i2c.c:	__set_bit(BTN_TOUCH, ts->input->keybit);
elants_i2c.c:	__set_bit(EV_ABS, ts->input->evbit);
elants_i2c.c:	__set_bit(EV_KEY, ts->input->evbit);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_X, 0, ts->x_max, 0, 0);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_Y, 0, ts->y_max, 0, 0);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_PRESSURE, 0, 255, 0, 0);
elants_i2c.c:	input_abs_set_res(ts->input, ABS_X, ts->x_res);
elants_i2c.c:	input_abs_set_res(ts->input, ABS_Y, ts->y_res);
elants_i2c.c:	error = input_mt_init_slots(ts->input, MAX_CONTACT_NUM,
elants_i2c.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->x_max, 0, 0);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->y_max, 0, 0);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
elants_i2c.c:	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
elants_i2c.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->x_res);
elants_i2c.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->y_res);
elants_i2c.c:	error = input_register_device(ts->input);
elants_i2c.c:	if (ts->iap_mode != ELAN_IAP_OPERATIONAL)
elants_i2c.c:		ts->wake_irq_enabled = (enable_irq_wake(client->irq) == 0);
elants_i2c.c:	} else if (ts->keep_power_in_suspend) {
elants_i2c.c:		if (ts->wake_irq_enabled)
elants_i2c.c:	} else if (ts->keep_power_in_suspend) {
elants_i2c.c:	ts->state = ELAN_STATE_NORMAL;
fts_521/fts.c:	    alloc_workqueue("fts-event-queue",
fts_521/fts.c:	    alloc_workqueue("fts-irq-queue",
fts_521/fts.c:	    alloc_workqueue("fts-fwu-queue",
fts_521/fts.c:	    alloc_workqueue("fts-touch-feature",
goodix.c:		error = goodix_i2c_read(ts->client, GOODIX_READ_COOR_ADDR,
goodix.c:			dev_err(&ts->client->dev, "I2C transfer error: %d\n",
goodix.c:			if (touch_num > ts->max_touch_num)
goodix.c:				error = goodix_i2c_read(ts->client,
goodix.c:	if (ts->inverted_x)
goodix.c:		input_x = ts->abs_x_max - input_x;
goodix.c:	if (ts->inverted_y)
goodix.c:		input_y = ts->abs_y_max - input_y;
goodix.c:	if (ts->swapped_x_y)
goodix.c:	input_mt_slot(ts->input_dev, id);
goodix.c:	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
goodix.c:	input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
goodix.c:	input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
goodix.c:	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
goodix.c:	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);
goodix.c:	input_report_key(ts->input_dev, KEY_LEFTMETA, point_data[0] & BIT(4));
goodix.c:	input_mt_sync_frame(ts->input_dev);
goodix.c:	input_sync(ts->input_dev);
goodix.c:	if (goodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0) < 0)
goodix.c:		dev_err(&ts->client->dev, "I2C write end_cmd error\n");
goodix.c:	devm_free_irq(&ts->client->dev, ts->client->irq, ts);
goodix.c:	return devm_request_threaded_irq(&ts->client->dev, ts->client->irq,
goodix.c:					 ts->irq_flags, ts->client->name, ts);
goodix.c:		dev_err(&ts->client->dev,
goodix.c:		dev_err(&ts->client->dev,
goodix.c:		dev_err(&ts->client->dev,
goodix.c:	error = goodix_i2c_write(ts->client, GOODIX_REG_CONFIG_DATA, cfg->data,
goodix.c:		dev_err(&ts->client->dev, "Failed to write config data: %d",
goodix.c:	dev_dbg(&ts->client->dev, "Config sent successfully.");
goodix.c:	error = gpiod_direction_output(ts->gpiod_int, 0);
goodix.c:	error = gpiod_direction_input(ts->gpiod_int);
goodix.c:	error = gpiod_direction_output(ts->gpiod_rst, 0);
goodix.c:	error = gpiod_direction_output(ts->gpiod_int, ts->client->addr == 0x14);
goodix.c:	error = gpiod_direction_output(ts->gpiod_rst, 1);
goodix.c:	error = gpiod_direction_input(ts->gpiod_rst);
goodix.c:	if (!ts->client)
goodix.c:	dev = &ts->client->dev;
goodix.c:	ts->gpiod_int = gpiod;
goodix.c:	ts->gpiod_rst = gpiod;
goodix.c:	error = goodix_i2c_read(ts->client, GOODIX_REG_CONFIG_DATA,
goodix.c:				config, ts->cfg_len);
goodix.c:		dev_warn(&ts->client->dev,
goodix.c:		ts->abs_x_max = GOODIX_MAX_WIDTH;
goodix.c:		ts->abs_y_max = GOODIX_MAX_HEIGHT;
goodix.c:		if (ts->swapped_x_y)
goodix.c:			swap(ts->abs_x_max, ts->abs_y_max);
goodix.c:		ts->int_trigger_type = GOODIX_INT_TRIGGER;
goodix.c:		ts->max_touch_num = GOODIX_MAX_CONTACTS;
goodix.c:	ts->abs_x_max = get_unaligned_le16(&config[RESOLUTION_LOC]);
goodix.c:	ts->abs_y_max = get_unaligned_le16(&config[RESOLUTION_LOC + 2]);
goodix.c:	if (ts->swapped_x_y)
goodix.c:		swap(ts->abs_x_max, ts->abs_y_max);
goodix.c:	ts->int_trigger_type = config[TRIGGER_LOC] & 0x03;
goodix.c:	ts->max_touch_num = config[MAX_CONTACTS_LOC] & 0x0f;
goodix.c:	if (!ts->abs_x_max || !ts->abs_y_max || !ts->max_touch_num) {
goodix.c:		dev_err(&ts->client->dev,
goodix.c:		ts->abs_x_max = GOODIX_MAX_WIDTH;
goodix.c:		ts->abs_y_max = GOODIX_MAX_HEIGHT;
goodix.c:		if (ts->swapped_x_y)
goodix.c:			swap(ts->abs_x_max, ts->abs_y_max);
goodix.c:		ts->max_touch_num = GOODIX_MAX_CONTACTS;
goodix.c:		ts->inverted_x = true;
goodix.c:		ts->inverted_y = true;
goodix.c:		dev_dbg(&ts->client->dev,
goodix.c:	error = goodix_i2c_read(ts->client, GOODIX_REG_ID, buf, sizeof(buf));
goodix.c:		dev_err(&ts->client->dev, "read version failed: %d\n", error);
goodix.c:	if (kstrtou16(id_str, 10, &ts->id))
goodix.c:		ts->id = 0x1001;
goodix.c:	ts->version = get_unaligned_le16(&buf[4]);
goodix.c:	dev_info(&ts->client->dev, "ID %d, version: %04x\n", ts->id,
goodix.c:		 ts->version);
goodix.c:	ts->input_dev = devm_input_allocate_device(&ts->client->dev);
goodix.c:	if (!ts->input_dev) {
goodix.c:		dev_err(&ts->client->dev, "Failed to allocate input device.");
goodix.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
goodix.c:			     0, ts->abs_x_max, 0, 0);
goodix.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
goodix.c:			     0, ts->abs_y_max, 0, 0);
goodix.c:	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
goodix.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
goodix.c:	input_mt_init_slots(ts->input_dev, ts->max_touch_num,
goodix.c:	ts->input_dev->name = "Goodix Capacitive TouchScreen";
goodix.c:	ts->input_dev->phys = "input/ts";
goodix.c:	ts->input_dev->id.bustype = BUS_I2C;
goodix.c:	ts->input_dev->id.vendor = 0x0416;
goodix.c:	ts->input_dev->id.product = ts->id;
goodix.c:	ts->input_dev->id.version = ts->version;
goodix.c:	input_set_capability(ts->input_dev, EV_KEY, KEY_LEFTMETA);
goodix.c:	error = input_register_device(ts->input_dev);
goodix.c:		dev_err(&ts->client->dev,
goodix.c:	ts->swapped_x_y = device_property_read_bool(&ts->client->dev,
goodix.c:	ts->inverted_x = device_property_read_bool(&ts->client->dev,
goodix.c:	ts->inverted_y = device_property_read_bool(&ts->client->dev,
goodix.c:	ts->irq_flags = goodix_irq_flags[ts->int_trigger_type] | IRQF_ONESHOT;
goodix.c:		dev_err(&ts->client->dev, "request IRQ failed: %d\n", error);
goodix.c:	complete_all(&ts->firmware_loading_complete);
goodix.c:	ts->client = client;
goodix.c:	init_completion(&ts->firmware_loading_complete);
goodix.c:	if (ts->gpiod_int && ts->gpiod_rst) {
goodix.c:	ts->cfg_len = goodix_get_cfg_len(ts->id);
goodix.c:	if(0){
goodix.c:		ts->cfg_name = devm_kasprintf(&client->dev, GFP_KERNEL,
goodix.c:					      "goodix_%d_cfg.bin", ts->id);
goodix.c:		if (!ts->cfg_name)
goodix.c:		error = request_firmware_nowait(THIS_MODULE, true, ts->cfg_name,
goodix.c:	if (ts->gpiod_int && ts->gpiod_rst)
goodix.c:		wait_for_completion(&ts->firmware_loading_complete);
goodix.c:	if (!ts->gpiod_int || !ts->gpiod_rst) {
goodix.c:	wait_for_completion(&ts->firmware_loading_complete);
goodix.c:	error = gpiod_direction_output(ts->gpiod_int, 0);
goodix.c:	error = goodix_i2c_write_u8(ts->client, GOODIX_REG_COMMAND,
goodix.c:		dev_err(&ts->client->dev, "Screen off command failed\n");
goodix.c:		gpiod_direction_input(ts->gpiod_int);
goodix.c:	if (!ts->gpiod_int || !ts->gpiod_rst) {
goodix.c:	error = gpiod_direction_output(ts->gpiod_int, 1);
goodix_driver_gt9886/docs/porting-guide-gsx.txt:	goodix-ts-dtsi.txt ： devicetree配置指导文档。
goodix_driver_gt9886/docs/porting-guide-gsx.txt:3) 参照《goodix-ts-dtsi.txt》配置devicetree文件。
goodix_fwupload.c:	snprintf(fw_name, sizeof(fw_name), "goodix/%s", ts->firmware_name);
goodix_fwupload.c:	error = request_firmware(&fw, fw_name, &ts->client->dev);
goodix_fwupload.c:		dev_err(&ts->client->dev, "Firmware request error %d\n", error);
goodix_fwupload.c:	error = goodix_firmware_verify(&ts->client->dev, fw);
goodix_fwupload.c:	error = goodix_enter_upload_mode(ts->client);
goodix_fwupload.c:	error = goodix_i2c_write_u8(ts->client,
goodix_fwupload.c:	error = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,
goodix_fwupload.c:	error = goodix_i2c_write_u8(ts->client,
goodix_fwupload.c:	error = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,
goodix_fwupload.c:	error = goodix_i2c_write_u8(ts->client,
goodix_fwupload.c:	error = goodix_i2c_write(ts->client, GOODIX_FW_UPLOAD_ADDRESS,
goodix_fwupload.c:	error = goodix_start_firmware(ts->client);
goodix_fwupload.c:	if (ts->bak_ref)
goodix_fwupload.c:	have_key = (ts->config[GOODIX_CFG_LOC_HAVE_KEY] & 0x01);
goodix_fwupload.c:	driver_num = (ts->config[GOODIX_CFG_LOC_DRVA_NUM] & 0x1f) +
goodix_fwupload.c:		     (ts->config[GOODIX_CFG_LOC_DRVB_NUM] & 0x1f);
goodix_fwupload.c:	sensor_num = (ts->config[GOODIX_CFG_LOC_SENS_NUM] & 0x0f) +
goodix_fwupload.c:		     ((ts->config[GOODIX_CFG_LOC_SENS_NUM] >> 4) & 0x0f);
goodix_fwupload.c:	dev_dbg(&ts->client->dev, "Drv %d Sen %d Key %d\n",
goodix_fwupload.c:	ts->bak_ref_len = (driver_num * (sensor_num - 2) + 2) * 2;
goodix_fwupload.c:	ts->bak_ref = devm_kzalloc(&ts->client->dev,
goodix_fwupload.c:				   ts->bak_ref_len, GFP_KERNEL);
goodix_fwupload.c:	if (!ts->bak_ref)
goodix_fwupload.c:	ts->bak_ref[ts->bak_ref_len - 1] = 1;
goodix_fwupload.c:	device_property_read_u32(&ts->client->dev,
goodix_fwupload.c:		ts->main_clk[i] = main_clk;
goodix_fwupload.c:	ts->main_clk[GOODIX_MAIN_CLK_LEN - 1] = 256 - checksum;
goodix_fwupload.c:	return goodix_i2c_write(ts->client, GOODIX_REG_MAIN_CLK,
goodix_fwupload.c:				ts->main_clk, GOODIX_MAIN_CLK_LEN);
goodix_fwupload.c:	device_property_read_string(&ts->client->dev,
goodix_fwupload.c:				    "firmware-name", &ts->firmware_name);
goodix_fwupload.c:	if (!ts->firmware_name)
goodix_fwupload.c:	if (ts->irq_pin_access_method == IRQ_PIN_ACCESS_NONE) {
goodix_fwupload.c:		dev_err(&ts->client->dev, "Error no IRQ-pin access method, cannot upload fw.\n");
goodix_fwupload.c:	dev_info(&ts->client->dev, "Touchscreen controller needs fw-upload\n");
goodix_fwupload.c:	ts->load_cfg_from_disk = true;
goodix_fwupload.c:	error = goodix_i2c_read(ts->client, GOODIX_REG_REQUEST, &val, 1);
goodix_fwupload.c:		error = goodix_send_cfg(ts, ts->config, ts->chip->config_len);
goodix_fwupload.c:		error = goodix_i2c_write(ts->client, GOODIX_REG_BAK_REF,
goodix_fwupload.c:					 ts->bak_ref, ts->bak_ref_len);
goodix_fwupload.c:		dev_err_ratelimited(&ts->client->dev, "Unknown Request: 0x%02x\n", val);
goodix_fwupload.c:	goodix_i2c_write_u8(ts->client,
goodix_fwupload.c:	if (!ts->firmware_name)
goodix_fwupload.c:	error = goodix_i2c_read(ts->client, GOODIX_REG_STATUS, &val, 1);
goodix_fwupload.c:	error = goodix_i2c_read(ts->client, GOODIX_REG_BAK_REF,
goodix_fwupload.c:				ts->bak_ref, ts->bak_ref_len);
goodix_fwupload.c:		memset(ts->bak_ref, 0, ts->bak_ref_len);
goodix_fwupload.c:		ts->bak_ref[ts->bak_ref_len - 1] = 1;
hideep.c:	struct pgm_packet *packet = (void *)ts->xfer_buf;
hideep.c:		.addr	= ts->client->addr,
hideep.c:	ret = i2c_transfer(ts->client->adapter, &msg, 1);
hideep.c:	struct pgm_packet *packet = (void *)ts->xfer_buf;
hideep.c:			.addr	= ts->client->addr,
hideep.c:			.addr	= ts->client->addr,
hideep.c:	ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
hideep.c:		dev_err(&ts->client->dev,
hideep.c:		dev_err(&ts->client->dev,
hideep.c:	error = regmap_bulk_write(ts->reg, p1, &p2, 1);
hideep.c:		dev_err(&ts->client->dev,
hideep.c:			dev_err(&ts->client->dev,
hideep.c:			dev_err(&ts->client->dev, "%s: bad pattern: %#08x\n",
hideep.c:			dev_dbg(&ts->client->dev, "found magic code");
hideep.c:	dev_err(&ts->client->dev, "failed to  enter pgm mode\n");
hideep.c:	if (unmask_code != ts->nvm_mask)
hideep.c:		dev_warn(&ts->client->dev,
hideep.c:			 unmask_code, ts->nvm_mask);
hideep.c:	NVM_W_SFR(HIDEEP_NVM_MASK_OFS, ts->nvm_mask);
hideep.c:	struct pgm_packet *packet_r = (void *)ts->xfer_buf;
hideep.c:			dev_err(&ts->client->dev,
hideep.c:				dev_err(&ts->client->dev,
hideep.c:	struct pgm_packet *packet_r = (void *)ts->xfer_buf;
hideep.c:			dev_err(&ts->client->dev,
hideep.c:					dev_err(&ts->client->dev,
hideep.c:				 (void *)&ts->dwz_info,
hideep.c:				 sizeof(ts->dwz_info) / sizeof(__be32));
hideep.c:		dev_err(&ts->client->dev,
hideep.c:	product_code = be16_to_cpu(ts->dwz_info.product_code);
hideep.c:		dev_dbg(&ts->client->dev, "used crimson IC");
hideep.c:		ts->fw_size = 1024 * 48;
hideep.c:		ts->nvm_mask = 0x00310000;
hideep.c:		dev_dbg(&ts->client->dev, "used lime IC");
hideep.c:		ts->fw_size = 1024 * 64;
hideep.c:		ts->nvm_mask = 0x0030027B;
hideep.c:		dev_err(&ts->client->dev, "product code is wrong: %#04x",
hideep.c:	dev_dbg(&ts->client->dev, "firmware release version: %#04x",
hideep.c:		be16_to_cpu(ts->dwz_info.release_ver));
hideep.c:	dev_dbg(&ts->client->dev, "starting firmware update");
hideep.c:		dev_err(&ts->client->dev,
hideep.c:		dev_dbg(&ts->client->dev, "firmware updated successfully\n");
hideep.c:		dev_err(&ts->client->dev,
hideep.c:	error = regulator_enable(ts->vcc_vdd);
hideep.c:		dev_err(&ts->client->dev,
hideep.c:	error = regulator_enable(ts->vcc_vid);
hideep.c:		dev_err(&ts->client->dev,
hideep.c:	if (ts->reset_gpio) {
hideep.c:		gpiod_set_value_cansleep(ts->reset_gpio, 0);
hideep.c:		error = regmap_write(ts->reg, HIDEEP_RESET_CMD, 0x01);
hideep.c:			dev_err(&ts->client->dev,
hideep.c:	if (ts->reset_gpio)
hideep.c:		gpiod_set_value(ts->reset_gpio, 1);
hideep.c:	regulator_disable(ts->vcc_vid);
hideep.c:	regulator_disable(ts->vcc_vdd);
hideep.c:			(void *)&ts->xfer_buf[HIDEEP_TOUCH_EVENT_INDEX];
hideep.c:	const u8 *keys = &ts->xfer_buf[HIDEEP_KEY_EVENT_INDEX];
hideep.c:	int touch_count = ts->xfer_buf[0];
hideep.c:	int key_count = ts->xfer_buf[1] & 0x0f;
hideep.c:	int lpm_count = ts->xfer_buf[1] & 0xf0;
hideep.c:	dev_dbg(&ts->client->dev, "mt = %d, key = %d, lpm = %02x",
hideep.c:		hideep_report_slot(ts->input_dev, events + i);
hideep.c:		input_report_key(ts->input_dev,
hideep.c:				 ts->key_codes[key_data & HIDEEP_KEY_IDX_MASK],
hideep.c:	input_mt_sync_frame(ts->input_dev);
hideep.c:	input_sync(ts->input_dev);
hideep.c:	error = regmap_bulk_read(ts->reg, HIDEEP_EVENT_ADDR,
hideep.c:				 ts->xfer_buf, HIDEEP_MAX_EVENT / 2);
hideep.c:		dev_err(&ts->client->dev, "failed to read events: %d\n", error);
hideep.c:	error = regmap_bulk_read(ts->reg, 0x28, val, ARRAY_SIZE(val));
hideep.c:	ts->prop.max_x = le16_to_cpup(val);
hideep.c:	ts->prop.max_y = le16_to_cpup(val + 1);
hideep.c:	dev_dbg(&ts->client->dev, "X: %d, Y: %d",
hideep.c:		ts->prop.max_x, ts->prop.max_y);
hideep.c:	struct device *dev = &ts->client->dev;
hideep.c:	ts->input_dev = devm_input_allocate_device(dev);
hideep.c:	if (!ts->input_dev) {
hideep.c:	ts->input_dev->name = HIDEEP_TS_NAME;
hideep.c:	ts->input_dev->id.bustype = BUS_I2C;
hideep.c:	input_set_drvdata(ts->input_dev, ts);
hideep.c:	input_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_X);
hideep.c:	input_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_Y);
hideep.c:	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, 65535, 0, 0);
hideep.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
hideep.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOOL_TYPE,
hideep.c:	touchscreen_parse_properties(ts->input_dev, true, &ts->prop);
hideep.c:	if (ts->prop.max_x == 0 || ts->prop.max_y == 0) {
hideep.c:	error = input_mt_init_slots(ts->input_dev, HIDEEP_MT_MAX,
hideep.c:	ts->key_num = device_property_count_u32(dev, "linux,keycodes");
hideep.c:	if (ts->key_num > HIDEEP_KEY_MAX) {
hideep.c:			ts->key_num);
hideep.c:	if (ts->key_num <= 0) {
hideep.c:						       ts->key_codes,
hideep.c:						       ts->key_num);
hideep.c:		if (ts->key_num) {
hideep.c:			ts->input_dev->keycode = ts->key_codes;
hideep.c:			ts->input_dev->keycodesize = sizeof(ts->key_codes[0]);
hideep.c:			ts->input_dev->keycodemax = ts->key_num;
hideep.c:			for (i = 0; i < ts->key_num; i++)
hideep.c:				input_set_capability(ts->input_dev, EV_KEY,
hideep.c:					ts->key_codes[i]);
hideep.c:	error = input_register_device(ts->input_dev);
hideep.c:			    be16_to_cpu(ts->dwz_info.product_id));
hideep.c:	if (fw_entry->size > ts->fw_size) {
hideep.c:			fw_entry->size, ts->fw_size);
hideep.c:	mutex_lock(&ts->dev_mutex);
hideep.c:	mutex_unlock(&ts->dev_mutex);
hideep.c:	mutex_lock(&ts->dev_mutex);
hideep.c:			be16_to_cpu(ts->dwz_info.release_ver));
hideep.c:	mutex_unlock(&ts->dev_mutex);
hideep.c:	mutex_lock(&ts->dev_mutex);
hideep.c:			be16_to_cpu(ts->dwz_info.product_id));
hideep.c:	mutex_unlock(&ts->dev_mutex);
hideep.c:	if (device_property_read_bool(&ts->client->dev, "hideep,force-native-protocol"))
hideep.c:		regmap_write(ts->reg, HIDEEP_WORK_MODE, 0x00);
hideep.c:	ts->client = client;
hideep.c:	mutex_init(&ts->dev_mutex);
hideep.c:	ts->reg = devm_regmap_init_i2c(client, &hideep_regmap_config);
hideep.c:	if (IS_ERR(ts->reg)) {
hideep.c:		error = PTR_ERR(ts->reg);
hideep.c:	ts->vcc_vdd = devm_regulator_get(&client->dev, "vdd");
hideep.c:	if (IS_ERR(ts->vcc_vdd))
hideep.c:		return PTR_ERR(ts->vcc_vdd);
hideep.c:	ts->vcc_vid = devm_regulator_get(&client->dev, "vid");
hideep.c:	if (IS_ERR(ts->vcc_vid))
hideep.c:		return PTR_ERR(ts->vcc_vid);
hideep.c:	ts->reset_gpio = devm_gpiod_get_optional(&client->dev,
hideep.c:	if (IS_ERR(ts->reset_gpio))
hideep.c:		return PTR_ERR(ts->reset_gpio);
himax_hx83112b.c:	error = regmap_write(ts->regmap, HIMAX_REG_CFG_SET_ADDR, address);
himax_hx83112b.c:	error = regmap_write(ts->regmap, HIMAX_REG_CFG_INIT_READ, 0x0);
himax_hx83112b.c:	error = regmap_read(ts->regmap, HIMAX_REG_CFG_READ_VALUE, dst);
himax_hx83112b.c:	gpiod_set_value_cansleep(ts->gpiod_rst, 1);
himax_hx83112b.c:	gpiod_set_value_cansleep(ts->gpiod_rst, 0);
himax_hx83112b.c:	dev_dbg(&ts->client->dev, "Product id: %x\n", product_id);
himax_hx83112b.c:		dev_err(&ts->client->dev,
himax_hx83112b.c:	ts->input_dev = devm_input_allocate_device(&ts->client->dev);
himax_hx83112b.c:	if (!ts->input_dev) {
himax_hx83112b.c:		dev_err(&ts->client->dev, "Failed to allocate input device\n");
himax_hx83112b.c:	ts->input_dev->name = "Himax Touchscreen";
himax_hx83112b.c:	input_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_X);
himax_hx83112b.c:	input_set_capability(ts->input_dev, EV_ABS, ABS_MT_POSITION_Y);
himax_hx83112b.c:	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);
himax_hx83112b.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 200, 0, 0);
himax_hx83112b.c:	touchscreen_parse_properties(ts->input_dev, true, &ts->props);
himax_hx83112b.c:	error = input_mt_init_slots(ts->input_dev, HIMAX_MAX_POINTS,
himax_hx83112b.c:		dev_err(&ts->client->dev,
himax_hx83112b.c:	error = input_register_device(ts->input_dev);
himax_hx83112b.c:		dev_err(&ts->client->dev,
himax_hx83112b.c:	input_mt_slot(ts->input_dev, point_index);
himax_hx83112b.c:	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
himax_hx83112b.c:	touchscreen_report_pos(ts->input_dev, &ts->props, x, y, true);
himax_hx83112b.c:	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
himax_hx83112b.c:	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
himax_hx83112b.c:	input_mt_sync_frame(ts->input_dev);
himax_hx83112b.c:	input_sync(ts->input_dev);
himax_hx83112b.c:		dev_err(&ts->client->dev, "Wrong event checksum: %04x\n",
himax_hx83112b.c:	error = regmap_raw_read(ts->regmap, HIMAX_REG_READ_EVENT, &event,
himax_hx83112b.c:		dev_err(&ts->client->dev, "Failed to read input event: %d\n",
himax_hx83112b.c:	ts->client = client;
himax_hx83112b.c:	ts->regmap = devm_regmap_init_i2c(client, &himax_regmap_config);
himax_hx83112b.c:	error = PTR_ERR_OR_ZERO(ts->regmap);
himax_hx83112b.c:	ts->gpiod_rst = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
himax_hx83112b.c:	error = PTR_ERR_OR_ZERO(ts->gpiod_rst);
himax_hx83112b.c:	disable_irq(ts->client->irq);
himax_hx83112b.c:	enable_irq(ts->client->irq);
hxchipset/himax_common.c:		count = snprintf(temp_buf, len, "%d\n", ts->HSEN_enable);
hxchipset/himax_common.c:		ts->HSEN_enable = 0;
hxchipset/himax_common.c:		ts->HSEN_enable = 1;
hxchipset/himax_common.c:	g_core_fp.fp_set_HSEN_enable(ts->HSEN_enable, ts->suspended);
hxchipset/himax_common.c:	D("%s: HSEN_enable = %d.\n", __func__, ts->HSEN_enable);
hxchipset/himax_common.c:		count = snprintf(temp_buf, len, "%d\n", ts->SMWP_enable);
hxchipset/himax_common.c:		ts->SMWP_enable = 0;
hxchipset/himax_common.c:		ts->SMWP_enable = 1;
hxchipset/himax_common.c:	g_core_fp.fp_set_SMWP_enable(ts->SMWP_enable, ts->suspended);
hxchipset/himax_common.c:	HX_SMWP_EN = ts->SMWP_enable;
hxchipset/himax_common.c:				"ges_en[%d]=%d\n", i, ts->gesture_cust_en[i]);
hxchipset/himax_common.c:			ts->gesture_cust_en[i] = 0;
hxchipset/himax_common.c:			ts->gesture_cust_en[i] = 1;
hxchipset/himax_common.c:			ts->gesture_cust_en[i] = 0;
hxchipset/himax_common.c:		I("gesture en[%d]=%d\n", i, ts->gesture_cust_en[i]);
hxchipset/himax_common.c:	set_bit(EV_SYN, ts->input_dev->evbit);
hxchipset/himax_common.c:	set_bit(EV_ABS, ts->input_dev->evbit);
hxchipset/himax_common.c:	set_bit(EV_KEY, ts->input_dev->evbit);
hxchipset/himax_common.c:	set_bit(KEY_BACK, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_HOME, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_MENU, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_SEARCH, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_POWER, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_01, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_02, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_03, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_04, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_05, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_06, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_07, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_08, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_09, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_10, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_11, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_12, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_13, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_14, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_CUST_15, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(BTN_TOUCH, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(KEY_APPSELECT, ts->input_dev->keybit);
hxchipset/himax_common.c:	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
hxchipset/himax_common.c:	/* ts->input_dev->mtsize = ts->nFinger_support; */
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 3, 0, 0);
hxchipset/himax_common.c:	set_bit(MT_TOOL_FINGER, ts->input_dev->keybit);
hxchipset/himax_common.c:	input_mt_init_slots(ts->input_dev, HX_TOUCH_ID_MAX, INPUT_MT_DIRECT);
hxchipset/himax_common.c:	input_mt_init_slots(ts->input_dev, HX_TOUCH_ID_MAX);
hxchipset/himax_common.c:		ts->pdata->abs_x_min, ts->pdata->abs_x_max,
hxchipset/himax_common.c:		ts->pdata->abs_y_min, ts->pdata->abs_y_max);
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, ts->pdata->abs_x_min, ts->pdata->abs_x_max, ts->pdata->abs_x_fuzz, 0);
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, ts->pdata->abs_y_min, ts->pdata->abs_y_max, ts->pdata->abs_y_fuzz, 0);
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->pdata->abs_pressure_min, ts->pdata->abs_pressure_max, ts->pdata->abs_pressure_fuzz, 0);
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, ts->pdata->abs_pressure_min, ts->pdata->abs_pressure_max, ts->pdata->abs_pressure_fuzz, 0);
hxchipset/himax_common.c:	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, ts->pdata->abs_width_min, ts->pdata->abs_width_max, ts->pdata->abs_pressure_fuzz, 0);
hxchipset/himax_common.c:	/* input_set_abs_params(ts->input_dev, ABS_MT_AMPLITUDE, 0, ((ts->pdata->abs_pressure_max << 16) | ts->pdata->abs_width_max), 0, 0); */
hxchipset/himax_common.c:	/* input_set_abs_params(ts->input_dev, ABS_MT_POSITION, 0, (BIT(31) | (ts->pdata->abs_x_max << 16) | ts->pdata->abs_y_max), 0, 0); */
hxchipset/himax_common.c:	if (himax_input_register_device(ts->input_dev) == 0)
hxchipset/himax_common.c:		private_ts->dev)) {
hxchipset/himax_common.c:	if (private_ts->in_self_test == 1) {
hxchipset/himax_common.c:		if (!ts->gesture_cust_en[gesture_flag]) {
hxchipset/himax_common.c:		if (!ts->gesture_cust_en[0]) {
hxchipset/himax_common.c:		input_report_key(private_ts->input_dev, KEY_EVENT, 1);
hxchipset/himax_common.c:		input_sync(private_ts->input_dev);
hxchipset/himax_common.c:		input_report_key(private_ts->input_dev, KEY_EVENT, 0);
hxchipset/himax_common.c:		input_sync(private_ts->input_dev);
hxchipset/himax_common.c:	if (ts->cable_config) {
hxchipset/himax_common.c:		if (((!!connect_status) != ts->usb_connected) || force_renew) {
hxchipset/himax_common.c:				ts->cable_config[1] = 0x01;
hxchipset/himax_common.c:				ts->usb_connected = 0x01;
hxchipset/himax_common.c:				ts->cable_config[1] = 0x00;
hxchipset/himax_common.c:				ts->usb_connected = 0x00;
hxchipset/himax_common.c:			g_core_fp.fp_usb_detect_set(ts->cable_config);
hxchipset/himax_common.c:			I("%s: Cable status change: 0x%2.2X\n", __func__, ts->usb_connected);
hxchipset/himax_common.c:	hx_touch_data->diag_cmd = ts->diag_cmd;
hxchipset/himax_common.c:	if (atomic_read(&ts->suspend_mode) && (!FAKE_POWER_KEY_SEND) && (ts->SMWP_enable) && (!hx_touch_data->diag_cmd))
hxchipset/himax_common.c:		&& (ts->in_self_test == 0)) {
hxchipset/himax_common.c:	ts->old_finger = ts->pre_finger_mask;
hxchipset/himax_common.c:	ts->pre_finger_mask = 0;
hxchipset/himax_common.c:	hx_touch_data->finger_num = hx_touch_data->hx_coord_buf[ts->coordInfoSize - 4] & 0x0F;
hxchipset/himax_common.c:	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
hxchipset/himax_common.c:		w = hx_touch_data->hx_coord_buf[(ts->nFinger_support * 4) + loop_i];
hxchipset/himax_common.c:		if (x >= 0 && x <= ts->pdata->abs_x_max && y >= 0 && y <= ts->pdata->abs_y_max) {
hxchipset/himax_common.c:			if (!ts->first_pressed) {
hxchipset/himax_common.c:				ts->first_pressed = 1;
hxchipset/himax_common.c:			ts->pre_finger_data[loop_i][0] = x;
hxchipset/himax_common.c:			ts->pre_finger_data[loop_i][1] = y;
hxchipset/himax_common.c:			ts->pre_finger_mask = ts->pre_finger_mask + (1 << loop_i);
hxchipset/himax_common.c:			if (loop_i == 0 && ts->first_pressed == 1) {
hxchipset/himax_common.c:				ts->first_pressed = 2;
hxchipset/himax_common.c:				D("E1@%d, %d\n", ts->pre_finger_data[0][0],
hxchipset/himax_common.c:					ts->pre_finger_data[0][1]);
hxchipset/himax_common.c:	p_point_num = ts->hx_point_num;
hxchipset/himax_common.c:	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
hxchipset/himax_common.c:		input_mt_slot(ts->input_dev, loop_i);
hxchipset/himax_common.c:		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
hxchipset/himax_common.c:	input_report_key(ts->input_dev, BTN_TOUCH, 0);
hxchipset/himax_common.c:	input_sync(ts->input_dev);
hxchipset/himax_common.c:			if (ts->pdata->virtual_key) {
hxchipset/himax_common.c:				if (ts->button[0].index) {
hxchipset/himax_common.c:					x_position = (ts->button[0].x_range_min + ts->button[0].x_range_max) / 2;
hxchipset/himax_common.c:					y_position = (ts->button[0].y_range_min + ts->button[0].y_range_max) / 2;
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, 0);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:				input_mt_slot(ts->input_dev, 0);
hxchipset/himax_common.c:				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_report_key(ts->input_dev, KEY_BACK, 1);
hxchipset/himax_common.c:			if (ts->pdata->virtual_key) {
hxchipset/himax_common.c:				if (ts->button[1].index) {
hxchipset/himax_common.c:					x_position = (ts->button[1].x_range_min + ts->button[1].x_range_max) / 2;
hxchipset/himax_common.c:					y_position = (ts->button[1].y_range_min + ts->button[1].y_range_max) / 2;
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, 0);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:				input_mt_slot(ts->input_dev, 0);
hxchipset/himax_common.c:				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_report_key(ts->input_dev, KEY_HOME, 1);
hxchipset/himax_common.c:			if (ts->pdata->virtual_key) {
hxchipset/himax_common.c:				if (ts->button[2].index) {
hxchipset/himax_common.c:					x_position = (ts->button[2].x_range_min + ts->button[2].x_range_max) / 2;
hxchipset/himax_common.c:					y_position = (ts->button[2].y_range_min + ts->button[2].y_range_max) / 2;
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, 0);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:				input_mt_slot(ts->input_dev, 0);
hxchipset/himax_common.c:				input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 100);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x_position);
hxchipset/himax_common.c:				input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y_position);
hxchipset/himax_common.c:				input_report_key(ts->input_dev, KEY_APPSELECT, 1);
hxchipset/himax_common.c:		input_sync(ts->input_dev);
hxchipset/himax_common.c:		input_mt_slot(ts->input_dev, 0);
hxchipset/himax_common.c:		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
hxchipset/himax_common.c:		input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, KEY_BACK, 0);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, KEY_HOME, 0);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, KEY_APPSELECT, 0);
hxchipset/himax_common.c:		input_sync(ts->input_dev);
hxchipset/himax_common.c:			input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:		input_sync(ts->input_dev);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:	input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:	input_sync(ts->input_dev);
hxchipset/himax_common.c:	for (i = 0; i < ts->nFinger_support; i++) {
hxchipset/himax_common.c:		if (g_target_report_data->x[i] >= 0 && g_target_report_data->x[i] <= ts->pdata->abs_x_max
hxchipset/himax_common.c:			&& g_target_report_data->y[i] >= 0 && g_target_report_data->y[i] <= ts->pdata->abs_y_max)
hxchipset/himax_common.c:			input_mt_slot(ts->input_dev, i);
hxchipset/himax_common.c:			ts->last_slot = i;
hxchipset/himax_common.c:			input_mt_report_slot_state(ts->input_dev,
hxchipset/himax_common.c:			input_report_key(ts->input_dev, BTN_TOUCH, g_target_report_data->finger_on);
hxchipset/himax_common.c:			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, g_target_report_data->w[i]);
hxchipset/himax_common.c:			input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, g_target_report_data->w[i]);
hxchipset/himax_common.c:			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, g_target_report_data->w[i]);
hxchipset/himax_common.c:			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, g_target_report_data->x[i]);
hxchipset/himax_common.c:			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, g_target_report_data->y[i]);
hxchipset/himax_common.c:			input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:			input_mt_slot(ts->input_dev, i);
hxchipset/himax_common.c:			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
hxchipset/himax_common.c:	input_report_key(ts->input_dev, BTN_TOUCH, g_target_report_data->finger_on);
hxchipset/himax_common.c:	input_sync(ts->input_dev);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, KEY_POWER, 1);
hxchipset/himax_common.c:		input_sync(ts->input_dev);
hxchipset/himax_common.c:		input_report_key(ts->input_dev, KEY_POWER, 0);
hxchipset/himax_common.c:		input_sync(ts->input_dev);
hxchipset/himax_common.c:	input_mt_sync(ts->input_dev);
hxchipset/himax_common.c:	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
hxchipset/himax_common.c:		if (((ts->old_finger >> loop_i) & 1) == 1) {
hxchipset/himax_common.c:			input_mt_slot(ts->input_dev, loop_i);
hxchipset/himax_common.c:			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
hxchipset/himax_common.c:	if (ts->pre_finger_mask > 0)
hxchipset/himax_common.c:		ts->pre_finger_mask = 0;
hxchipset/himax_common.c:	if (ts->first_pressed == 1) {
hxchipset/himax_common.c:		ts->first_pressed = 2;
hxchipset/himax_common.c:		I("E1@%d, %d\n", ts->pre_finger_data[0][0], ts->pre_finger_data[0][1]);
hxchipset/himax_common.c:	/* if (ts->debug_log_level & BIT(1)) */
hxchipset/himax_common.c:	input_report_key(ts->input_dev, BTN_TOUCH, hx_touch_data->finger_on);
hxchipset/himax_common.c:	input_sync(ts->input_dev);
hxchipset/himax_common.c:	if (ts->hx_point_num != 0)
hxchipset/himax_common.c:			ts->hx_point_num = 0;
hxchipset/himax_common.c:			ts->hx_point_num = hx_touch_data->hx_coord_buf[HX_TOUCH_INFO_POINT_CNT] & 0x0f;
hxchipset/himax_common.c:		__pm_wakeup_event(&ts->ts_SMWP_wake_src, TS_WAKE_LOCK_TIMEOUT);
hxchipset/himax_common.c:	queue_work(ts->himax_wq, &ts->work);
hxchipset/himax_common.c:	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
hxchipset/himax_common.c:	if (ts->cable_config) {
hxchipset/himax_common.c:		if (!atomic_read(&ts->suspend_mode)) {
hxchipset/himax_common.c:			if ((!!connect_status) != ts->usb_connected) {
hxchipset/himax_common.c:					ts->cable_config[1] = 0x01;
hxchipset/himax_common.c:					ts->usb_connected = 0x01;
hxchipset/himax_common.c:					ts->cable_config[1] = 0x00;
hxchipset/himax_common.c:					ts->usb_connected = 0x00;
hxchipset/himax_common.c:				if (himax_bus_master_write(ts->cable_config, sizeof(ts->cable_config), HIMAX_I2C_RETRY_TIMES) < 0) {
hxchipset/himax_common.c:				I("%s: Cable status change: 0x%2.2X\n", __func__, ts->cable_config[1]);
hxchipset/himax_common.c:				ts->usb_connected = 0x01;
hxchipset/himax_common.c:				ts->usb_connected = 0x00;
hxchipset/himax_common.c:			I("%s: Cable status remembered: 0x%2.2X\n", __func__, ts->usb_connected);
hxchipset/himax_common.c:	ts->fb_notif.notifier_call = drm_notifier_callback;
hxchipset/himax_common.c:	ret = msm_drm_register_client(&ts->fb_notif);
hxchipset/himax_common.c:	ts->fb_notif.notifier_call = fb_notifier_callback;
hxchipset/himax_common.c:	ret = fb_register_client(&ts->fb_notif);
hxchipset/himax_common.c:	struct himax_i2c_platform_data *pdata = ts->pdata;
hxchipset/himax_common.c:	ts->rst_gpio = pdata->gpio_reset;
hxchipset/himax_common.c:	queue_delayed_work(ts->himax_update_wq, &ts->work_update,
hxchipset/himax_common.c:	ts->himax_0f_update_wq = create_singlethread_workqueue("HMX_0f_update_request");
hxchipset/himax_common.c:	INIT_DELAYED_WORK(&ts->work_0f_update, g_core_fp.fp_0f_operation);
hxchipset/himax_common.c:	queue_delayed_work(ts->himax_0f_update_wq, &ts->work_0f_update, msecs_to_jiffies(2000));
hxchipset/himax_common.c:	ts->power = pdata->power;
hxchipset/himax_common.c:	ts->x_channel = ic_data->HX_RX_NUM;
hxchipset/himax_common.c:	ts->y_channel = ic_data->HX_TX_NUM;
hxchipset/himax_common.c:	ts->nFinger_support = ic_data->HX_MAX_PT;
hxchipset/himax_common.c:	calcDataSize(ts->nFinger_support);
hxchipset/himax_common.c:	ts->SMWP_enable = 0;
hxchipset/himax_common.c:	wakeup_source_init(&ts->ts_SMWP_wake_src, WAKE_LOCK_SUSPEND, HIMAX_common_NAME);
hxchipset/himax_common.c:	ts->HSEN_enable = 0;
hxchipset/himax_common.c:	ts->ito_test_wq = create_singlethread_workqueue("himax_ito_test_wq");
hxchipset/himax_common.c:	if (!ts->ito_test_wq) {
hxchipset/himax_common.c:	INIT_WORK(&ts->ito_test_work, himax_ito_test_work);
hxchipset/himax_common.c:	if (ts->cable_config)
hxchipset/himax_common.c:	destroy_workqueue(ts->ito_test_wq);
hxchipset/himax_common.c:	wakeup_source_trash(&ts->ts_SMWP_wake_src);
hxchipset/himax_common.c:		cancel_delayed_work_sync(&ts->work_update);
hxchipset/himax_common.c:		destroy_workqueue(ts->himax_update_wq);
hxchipset/himax_common.c:	if (!ts->use_irq) {
hxchipset/himax_common.c:		hrtimer_cancel(&ts->timer);
hxchipset/himax_common.c:		destroy_workqueue(ts->himax_wq);
hxchipset/himax_common.c:	destroy_workqueue(ts->ito_test_wq);
hxchipset/himax_common.c:	wakeup_source_trash(&ts->ts_SMWP_wake_src);
hxchipset/himax_common.c:	if (msm_drm_unregister_client(&ts->fb_notif))
hxchipset/himax_common.c:	if (fb_unregister_client(&ts->fb_notif))
hxchipset/himax_common.c:	input_free_device(ts->input_dev);
hxchipset/himax_common.c:	cancel_delayed_work_sync(&ts->work_0f_update);
hxchipset/himax_common.c:	destroy_workqueue(ts->himax_0f_update_wq);
hxchipset/himax_common.c:	cancel_delayed_work_sync(&ts->work_update);
hxchipset/himax_common.c:	destroy_workqueue(ts->himax_update_wq);
hxchipset/himax_common.c:	if (gpio_is_valid(ts->pdata->gpio_irq))
hxchipset/himax_common.c:		gpio_free(ts->pdata->gpio_irq);
hxchipset/himax_common.c:	if (gpio_is_valid(ts->pdata->gpio_reset))
hxchipset/himax_common.c:		gpio_free(ts->pdata->gpio_reset);
hxchipset/himax_common.c:	kfree(ts->pdata);
hxchipset/himax_common.c:	kfree(ts->i2c_data);
hxchipset/himax_common.c:	if (ts->suspended) {
hxchipset/himax_common.c:	ts->suspended = true;
hxchipset/himax_common.c:	g_core_fp.fp_resend_cmd_func(ts->suspended);
hxchipset/himax_common.c:	if (ts->SMWP_enable) {
hxchipset/himax_common.c:		atomic_set(&ts->suspend_mode, 1);
hxchipset/himax_common.c:		ts->pre_finger_mask = 0;
hxchipset/himax_common.c:	if (!ts->use_irq) {
hxchipset/himax_common.c:		ret = cancel_work_sync(&ts->work);
hxchipset/himax_common.c:	/* ts->first_pressed = 0; */
hxchipset/himax_common.c:	atomic_set(&ts->suspend_mode, 1);
hxchipset/himax_common.c:	ts->pre_finger_mask = 0;
hxchipset/himax_common.c:	if (ts->pdata->powerOff3V3 && ts->pdata->power)
hxchipset/himax_common.c:		ts->pdata->power(0);
hxchipset/himax_common.c:	if (ts->suspended == false) {
hxchipset/himax_common.c:	ts->suspended = false;
hxchipset/himax_common.c:	atomic_set(&ts->suspend_mode, 0);
hxchipset/himax_common.c:	if (ts->pdata->powerOff3V3 && ts->pdata->power)
hxchipset/himax_common.c:		ts->pdata->power(1);
hxchipset/himax_common.c:	g_core_fp.fp_resend_cmd_func(ts->suspended);
hxchipset/himax_debug.c:		queue_work(ts->ito_test_wq, &ts->ito_test_work);
hxchipset/himax_debug.c:	if (private_ts->chip_cell_type == CHIP_IS_ON_CELL)
hxchipset/himax_debug.c:	ret += snprintf(temp_buf + ret, len - ret, "%d ", ts->irq_enabled);
hxchipset/himax_debug.c:			ts->irq_enabled = 1;
hxchipset/himax_debug.c:		free_irq(ts->client->irq, ts);
hxchipset/himax_debug.c:		ts->irq_enabled = 0;
hxchipset/himax_debug.c:	ret += snprintf(temp_buf + ret, len - ret, "%d ", ts->pdata->abs_x_min);
hxchipset/himax_debug.c:	ret += snprintf(temp_buf + ret, len - ret, "%d ", ts->pdata->abs_x_max);
hxchipset/himax_debug.c:	ret += snprintf(temp_buf + ret, len - ret, "%d ", ts->pdata->abs_y_min);
hxchipset/himax_debug.c:	ret += snprintf(temp_buf + ret, len - ret, "%d ", ts->pdata->abs_y_max);
hxchipset/himax_debug.c:		ts->pdata->abs_x_min = layout[0];
hxchipset/himax_debug.c:		ts->pdata->abs_x_max = layout[1];
hxchipset/himax_debug.c:		ts->pdata->abs_y_min = layout[2];
hxchipset/himax_debug.c:		ts->pdata->abs_y_max = layout[3];
hxchipset/himax_debug.c:		  ts->pdata->abs_x_min, ts->pdata->abs_x_max, ts->pdata->abs_y_min, ts->pdata->abs_y_max);
hxchipset/himax_debug.c:		input_unregister_device(ts->input_dev);
hxchipset/himax_debug.c:		  ts->pdata->abs_x_min, ts->pdata->abs_x_max, ts->pdata->abs_y_min, ts->pdata->abs_y_max);
hxchipset/himax_debug.c:	ts->debug_log_level = 0;
hxchipset/himax_debug.c:			ts->debug_log_level |= (buf_tmp[i] - '0');
hxchipset/himax_debug.c:			ts->debug_log_level |= (buf_tmp[i] - 'A' + 10);
hxchipset/himax_debug.c:			ts->debug_log_level |= (buf_tmp[i] - 'a' + 10);
hxchipset/himax_debug.c:			ts->debug_log_level <<= 4;
hxchipset/himax_debug.c:	if (ts->debug_log_level & BIT(3)) {
hxchipset/himax_debug.c:		if (ts->pdata->screenWidth > 0 && ts->pdata->screenHeight > 0 &&
hxchipset/himax_debug.c:			(ts->pdata->abs_x_max - ts->pdata->abs_x_min) > 0 &&
hxchipset/himax_debug.c:			(ts->pdata->abs_y_max - ts->pdata->abs_y_min) > 0) {
hxchipset/himax_debug.c:			ts->widthFactor = (ts->pdata->screenWidth << SHIFTBITS) / (ts->pdata->abs_x_max - ts->pdata->abs_x_min);
hxchipset/himax_debug.c:			ts->heightFactor = (ts->pdata->screenHeight << SHIFTBITS) / (ts->pdata->abs_y_max - ts->pdata->abs_y_min);
hxchipset/himax_debug.c:			if (ts->widthFactor > 0 && ts->heightFactor > 0)
hxchipset/himax_debug.c:				ts->useScreenRes = 1;
hxchipset/himax_debug.c:				ts->heightFactor = 0;
hxchipset/himax_debug.c:				ts->widthFactor = 0;
hxchipset/himax_debug.c:				ts->useScreenRes = 0;
hxchipset/himax_debug.c:		ts->useScreenRes = 0;
hxchipset/himax_debug.c:		ts->widthFactor = 0;
hxchipset/himax_debug.c:		ts->heightFactor = 0;
hxchipset/himax_debug.c:			if (strcmp(HX_85XX_H_SERIES_PWON, private_ts->chip_name) == 0 && cfg_flag == 0)
hxchipset/himax_debug.c:				if (strcmp(HX_85XX_H_SERIES_PWON, private_ts->chip_name) == 0 && cfg_flag == 0)
hxchipset/himax_debug.c:	hx_touch_data->diag_cmd = ts->diag_cmd;
hxchipset/himax_debug.c:		for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
hxchipset/himax_debug.c:			if (g_target_report_data->x[loop_i] >= 0 && g_target_report_data->x[loop_i] <= ts->pdata->abs_x_max && g_target_report_data->y[loop_i] >= 0 && g_target_report_data->y[loop_i] <= ts->pdata->abs_y_max) {
hxchipset/himax_debug.c:		for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
hxchipset/himax_debug.c:			if (((ts->old_finger >> loop_i & 1) == 0) && ((ts->pre_finger_mask >> loop_i & 1) == 1)) {
hxchipset/himax_debug.c:				if (g_target_report_data->x[loop_i] >= 0 && g_target_report_data->x[loop_i] <= ts->pdata->abs_x_max && g_target_report_data->y[loop_i] >= 0 && g_target_report_data->y[loop_i] <= ts->pdata->abs_y_max)
hxchipset/himax_debug.c:			} else if ((((ts->old_finger >> loop_i & 1) == 1) && ((ts->pre_finger_mask >> loop_i & 1) == 0)))
hxchipset/himax_debug.c:				I("status: Raw:F:%02d Up, X:%d, Y:%d\n", loop_i + 1, ts->pre_finger_data[loop_i][0], ts->pre_finger_data[loop_i][1]);
hxchipset/himax_debug.c:			 *	I("dbg hx_point_num=%d,old_finger=0x%02X,pre_finger_mask=0x%02X\n",ts->hx_point_num,ts->old_finger,ts->pre_finger_mask);
hxchipset/himax_debug.c:	switch (ts->debug_log_level) {
hxchipset/himax_debug.c:	dsram_type = ts->diag_cmd / 10;
hxchipset/himax_debug.c:	if (Is_2T2R && (ts->diag_cmd >= 4 && ts->diag_cmd <= 6)) {
hxchipset/himax_debug.c:	if ((ts->diag_cmd >= 1 && ts->diag_cmd <= 3) || (ts->diag_cmd == 7)) {
hxchipset/himax_debug.c:	else if (Is_2T2R && ts->diag_cmd >= 4 && ts->diag_cmd <= 6) {
hxchipset/himax_debug.c:	else if (ts->diag_cmd == 8) {
hxchipset/himax_debug.c:	if ((ts->diag_cmd >= 1 && ts->diag_cmd <= 7) || dsram_type > 0) {
hxchipset/himax_debug.c:	dsram_type = ts->diag_cmd / 10;
hxchipset/himax_debug.c:	I("%s:Entering ts->diag_cmd=%d\n!", __func__, ts->diag_cmd);
hxchipset/himax_debug.c:		queue_delayed_work(private_ts->himax_diag_wq, &private_ts->himax_diag_delay_wrok, 1 / 10 * HZ);
hxchipset/himax_debug.c:				queue_delayed_work(private_ts->himax_diag_wq, &private_ts->himax_diag_delay_wrok, 1 / 10 * HZ);
hxchipset/himax_debug.c:		ts->diag_cmd = messages[0] - '0';
hxchipset/himax_debug.c:		ts->diag_cmd = (messages[0] - '0') * 10 + (messages[1] - '0');
hxchipset/himax_debug.c:	storage_type = g_core_fp.fp_determin_diag_storage(ts->diag_cmd);
hxchipset/himax_debug.c:	rawdata_type = g_core_fp.fp_determin_diag_rawdata(ts->diag_cmd);
hxchipset/himax_debug.c:	if (ts->diag_cmd > 0 && rawdata_type == 0) {
hxchipset/himax_debug.c:		I("[Himax]ts->diag_cmd=0x%x ,storage_type=%d, rawdata_type=%d! Maybe no support!\n"
hxchipset/himax_debug.c:		  , ts->diag_cmd, storage_type, rawdata_type);
hxchipset/himax_debug.c:		ts->diag_cmd = 0x00;
hxchipset/himax_debug.c:		I("[Himax]ts->diag_cmd=0x%x ,storage_type=%d, rawdata_type=%d\n", ts->diag_cmd, storage_type, rawdata_type);
hxchipset/himax_debug.c:			cancel_delayed_work(&private_ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:		if (ts->diag_cmd == 0x04) {
hxchipset/himax_debug.c:			command[0] = ts->diag_cmd;
hxchipset/himax_debug.c:			ts->diag_cmd = 0x00;
hxchipset/himax_debug.c:			command[0] = ts->diag_cmd;
hxchipset/himax_debug.c:			cancel_delayed_work(&private_ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:		command[0] = rawdata_type;/* ts->diag_cmd; */
hxchipset/himax_debug.c:		queue_delayed_work(private_ts->himax_diag_wq, &private_ts->himax_diag_delay_wrok, 2 * HZ / 100);
hxchipset/himax_debug.c:			cancel_delayed_work(&private_ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:		queue_delayed_work(private_ts->himax_diag_wq, &private_ts->himax_diag_delay_wrok, 2 * HZ / 100);
hxchipset/himax_debug.c:			cancel_delayed_work(&private_ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:		if (ts->diag_cmd != 0x00) {
hxchipset/himax_debug.c:			E("[Himax]ts->diag_cmd error!diag_command=0x%x so reset\n", ts->diag_cmd);
hxchipset/himax_debug.c:			if (ts->diag_cmd != 0x08)
hxchipset/himax_debug.c:				ts->diag_cmd = 0x00;
hxchipset/himax_debug.c:			ts->diag_cmd = 0x00;
hxchipset/himax_debug.c:			I("return to normal ts->diag_cmd=0x%x\n", ts->diag_cmd);
hxchipset/himax_debug.c:		if (private_ts->chip_cell_type == CHIP_IS_ON_CELL)
hxchipset/himax_debug.c:		ret += snprintf(temp_buf + ret, len - ret, "%s\n", private_ts->chip_name);
hxchipset/himax_debug.c:		if (private_ts->protocol_type == PROTOCOL_TYPE_A)
hxchipset/himax_debug.c:		result = request_firmware(&fw, fileName, private_ts->dev);
hxchipset/himax_debug.c:		private_ts->himax_0f_update_wq = create_singlethread_workqueue("HMX_update_0f_reqest_write");
hxchipset/himax_debug.c:		if (!private_ts->himax_0f_update_wq)
hxchipset/himax_debug.c:		INIT_DELAYED_WORK(&private_ts->work_0f_update, g_core_fp.fp_0f_operation);
hxchipset/himax_debug.c:		queue_delayed_work(private_ts->himax_0f_update_wq, &private_ts->work_0f_update, msecs_to_jiffies(100));
hxchipset/himax_debug.c:		queue_work(private_ts->flash_wq, &private_ts->flash_work);
hxchipset/himax_debug.c:		queue_work(private_ts->flash_wq, &private_ts->flash_work);
hxchipset/himax_debug.c:	ts->flash_wq = create_singlethread_workqueue("himax_flash_wq");
hxchipset/himax_debug.c:	if (!ts->flash_wq) {
hxchipset/himax_debug.c:	INIT_WORK(&ts->flash_work, himax_ts_flash_work_func);
hxchipset/himax_debug.c:	ts->himax_diag_wq = create_singlethread_workqueue("himax_diag");
hxchipset/himax_debug.c:	if (!ts->himax_diag_wq) {
hxchipset/himax_debug.c:	INIT_DELAYED_WORK(&ts->himax_diag_delay_wrok, himax_ts_diag_work_func);
hxchipset/himax_debug.c:	cancel_delayed_work_sync(&ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:	destroy_workqueue(ts->himax_diag_wq);
hxchipset/himax_debug.c:	destroy_workqueue(ts->flash_wq);
hxchipset/himax_debug.c:	cancel_delayed_work_sync(&ts->himax_diag_delay_wrok);
hxchipset/himax_debug.c:	destroy_workqueue(ts->himax_diag_wq);
hxchipset/himax_debug.c:	destroy_workqueue(ts->flash_wq);
hxchipset/himax_ic_HX83112.c:				strlcpy(private_ts->chip_name, HX_83112A_SERIES_PWON, 30);
hxchipset/himax_ic_HX83112.c:				strlcpy(private_ts->chip_name, HX_83112B_SERIES_PWON, 30);
hxchipset/himax_ic_HX83112.c:			I("%s:IC name = %s\n", __func__, private_ts->chip_name);
hxchipset/himax_ic_HX83112.c:	private_ts->chip_cell_type = CHIP_IS_IN_CELL;
hxchipset/himax_ic_HX83112.c:	D("%s:IC cell type = %d\n",  __func__,  private_ts->chip_cell_type);
hxchipset/himax_ic_incell_core.c:	himax_rst_gpio_set(private_ts->rst_gpio, 0);
hxchipset/himax_ic_incell_core.c:			strlcpy(private_ts->chip_name, HX_83102A_SERIES_PWON, 30);
hxchipset/himax_ic_incell_core.c:		if (private_ts->use_irq)
hxchipset/himax_ic_incell_core.c:			hrtimer_start(&private_ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
hxchipset/himax_ic_incell_core.c:		if (private_ts->use_irq)
hxchipset/himax_ic_incell_core.c:			hrtimer_cancel(&private_ts->timer);
hxchipset/himax_ic_incell_core.c:			cancel_work_sync(&private_ts->work);
hxchipset/himax_ic_incell_core.c:	himax_rst_gpio_set(private_ts->rst_gpio, 0);
hxchipset/himax_ic_incell_core.c:	himax_rst_gpio_set(private_ts->rst_gpio, 1);
hxchipset/himax_ic_incell_core.c:	if (ts->rst_gpio >= 0) {
hxchipset/himax_ic_incell_core.c:	g_core_fp.fp_set_SMWP_enable(ts->SMWP_enable, suspended);
hxchipset/himax_ic_incell_core.c:	g_core_fp.fp_set_HSEN_enable(ts->HSEN_enable, suspended);
hxchipset/himax_ic_incell_core.c:	err = request_firmware(&fw_entry,  firmware_name,  private_ts->dev);
hxchipset/himax_ic_incell_core.c:	err = request_firmware(&fw_entry,  firmware_name,  private_ts->dev);
hxchipset/himax_platform.c:	ts->input_dev = input_allocate_device();
hxchipset/himax_platform.c:	if (ts->input_dev == NULL) {
hxchipset/himax_platform.c:	ts->input_dev->name = "himax-touchscreen";
hxchipset/himax_platform.c:	struct device_node *dt = private_ts->client->dev.of_node;
hxchipset/himax_platform.c:	uint8_t *buf = ts->i2c_data;
hxchipset/himax_platform.c:	struct i2c_client *client = ts->client;
hxchipset/himax_platform.c:	mutex_lock(&ts->rw_lock);
hxchipset/himax_platform.c:		mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	uint8_t *buf = ts->i2c_data;
hxchipset/himax_platform.c:	struct i2c_client *client = ts->client;
hxchipset/himax_platform.c:	mutex_lock(&ts->rw_lock);
hxchipset/himax_platform.c:		mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	uint8_t *buf = ts->i2c_data;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	mutex_lock(&ts->rw_lock);
hxchipset/himax_platform.c:		mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	mutex_unlock(&ts->rw_lock);
hxchipset/himax_platform.c:	irqnum = private_ts->client->irq;
hxchipset/himax_platform.c:		private_ts->irq_enabled = 1;
hxchipset/himax_platform.c:		private_ts->irq_enabled = 0;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	struct i2c_client *client = private_ts->client;
hxchipset/himax_platform.c:	ts->irq_enabled = 0;
hxchipset/himax_platform.c:		ts->use_irq = 1;
hxchipset/himax_platform.c:			ts->irq_enabled = 1;
hxchipset/himax_platform.c:			ts->use_irq = 0;
hxchipset/himax_platform.c:	if (!ts->use_irq) {
hxchipset/himax_platform.c:		ts->himax_wq = create_singlethread_workqueue("himax_touch");
hxchipset/himax_platform.c:		INIT_WORK(&ts->work, himax_ts_work_func);
hxchipset/himax_platform.c:		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
hxchipset/himax_platform.c:		ts->timer.function = himax_ts_timer_func;
hxchipset/himax_platform.c:		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
hxchipset/himax_platform.c:	if (!ts->initialized)
hxchipset/himax_platform.c:	if (!ts->initialized) {
hxchipset/himax_platform.c:		ts->initialized = true;
hxchipset/himax_platform.c:							ts->client) {
hxchipset/himax_platform.c:			if (!ts->initialized)
hxchipset/himax_platform.c:			himax_common_suspend(&ts->client->dev);
hxchipset/himax_platform.c:	if (evdata->data && event == MSM_DRM_EVENT_BLANK && ts && ts->client) {
hxchipset/himax_platform.c:			himax_common_resume(&ts->client->dev);
hxchipset/himax_platform.c:		ts->client) {
hxchipset/himax_platform.c:			himax_common_resume(&ts->client->dev);
hxchipset/himax_platform.c:			himax_common_suspend(&ts->client->dev);
hxchipset/himax_platform.c:	ts->client = client;
hxchipset/himax_platform.c:	ts->dev = &client->dev;
hxchipset/himax_platform.c:	mutex_init(&ts->rw_lock);
hxchipset/himax_platform.c:	ts->i2c_data = kmalloc(FLASH_RW_MAX_LEN + HX_CMD_BYTE, GFP_KERNEL);
hxchipset/himax_platform.c:	if (ts->i2c_data == NULL) {
hxchipset/himax_platform.c:	ts->initialized = false;
hxchipset/himax_platform.c:	ts->himax_update_wq =
hxchipset/himax_platform.c:	if (!ts->himax_update_wq) {
hxchipset/himax_platform.c:	INIT_DELAYED_WORK(&ts->work_update, himax_update_register);
hxchipset/himax_platform.c:		ts->button = pdata->virtual_key;
hxchipset/himax_platform.c:	ts->pdata = pdata;
hxchipset/himax_platform.c:	ts->pdata->abs_pressure_min = 0;
hxchipset/himax_platform.c:	ts->pdata->abs_pressure_max = 200;
hxchipset/himax_platform.c:	ts->pdata->abs_width_min = 0;
hxchipset/himax_platform.c:	ts->pdata->abs_width_max = 200;
hxchipset/himax_platform.c:	ts->suspended = false;
hxchipset/himax_platform.c:	ts->usb_connected = 0x00;
hxchipset/himax_platform.c:	ts->cable_config = pdata->cable_config;
hxchipset/himax_platform.c:	ts->protocol_type = PROTOCOL_TYPE_A;
hxchipset/himax_platform.c:	ts->protocol_type = PROTOCOL_TYPE_B;
hxchipset/himax_platform.c:	  ts->protocol_type == PROTOCOL_TYPE_A ? 'A' : 'B');
hxchipset/himax_platform.c:		  __func__, ts->input_dev->name);
hxchipset/himax_platform.c:	kfree(ts->i2c_data);
ilitek_ts_i2c.c:	struct i2c_client *client = ts->client;
ilitek_ts_i2c.c:	struct input_dev *input = ts->input_dev;
ilitek_ts_i2c.c:	touchscreen_report_pos(input, &ts->prop, x, y, true);
ilitek_ts_i2c.c:	struct input_dev *input = ts->input_dev;
ilitek_ts_i2c.c:	struct device *dev = &ts->client->dev;
ilitek_ts_i2c.c:	if (report_max_point > ts->max_tp) {
ilitek_ts_i2c.c:			report_max_point, ts->max_tp);
ilitek_ts_i2c.c:		if (x > ts->screen_max_x || x < ts->screen_min_x ||
ilitek_ts_i2c.c:		    y > ts->screen_max_y || y < ts->screen_min_y) {
ilitek_ts_i2c.c:				 ts->screen_min_x, x, ts->screen_max_x,
ilitek_ts_i2c.c:				 ts->screen_min_y, y, ts->screen_max_y);
ilitek_ts_i2c.c:	cmd = ts->ptl_cb_func[idx].cmd;
ilitek_ts_i2c.c:	error = ts->ptl_cb_func[idx].func(ts, cmd, inbuf, outbuf);
ilitek_ts_i2c.c:	ts->ptl.ver = get_unaligned_be16(outbuf);
ilitek_ts_i2c.c:	ts->ptl.ver_major = outbuf[0];
ilitek_ts_i2c.c:	ts->mcu_ver = get_unaligned_le16(outbuf);
ilitek_ts_i2c.c:	memset(ts->product_id, 0, sizeof(ts->product_id));
ilitek_ts_i2c.c:	memcpy(ts->product_id, outbuf + 6, 26);
ilitek_ts_i2c.c:	memcpy(ts->firmware_ver, outbuf, 8);
ilitek_ts_i2c.c:	ts->screen_min_x = get_unaligned_le16(outbuf);
ilitek_ts_i2c.c:	ts->screen_min_y = get_unaligned_le16(outbuf + 2);
ilitek_ts_i2c.c:	ts->screen_max_x = get_unaligned_le16(outbuf + 4);
ilitek_ts_i2c.c:	ts->screen_max_y = get_unaligned_le16(outbuf + 6);
ilitek_ts_i2c.c:	ts->max_tp = outbuf[8];
ilitek_ts_i2c.c:	if (ts->max_tp > ILITEK_SUPPORT_MAX_POINT) {
ilitek_ts_i2c.c:		dev_err(&ts->client->dev, "Invalid MAX_TP:%d from FW\n",
ilitek_ts_i2c.c:			ts->max_tp);
ilitek_ts_i2c.c:	ts->ic_mode = outbuf[0];
ilitek_ts_i2c.c:	if (ts->reset_gpio) {
ilitek_ts_i2c.c:		gpiod_set_value(ts->reset_gpio, 1);
ilitek_ts_i2c.c:		gpiod_set_value(ts->reset_gpio, 0);
ilitek_ts_i2c.c:	ts->ptl_cb_func = ptl_func_map;
ilitek_ts_i2c.c:	ts->reset_time = 600;
ilitek_ts_i2c.c:	if (ts->ptl.ver_major == 0x3 ||
ilitek_ts_i2c.c:	    ts->ptl.ver == BL_V1_6 ||
ilitek_ts_i2c.c:	    ts->ptl.ver == BL_V1_7)
ilitek_ts_i2c.c:	ts->input_dev = input;
ilitek_ts_i2c.c:			     ts->screen_min_x, ts->screen_max_x, 0, 0);
ilitek_ts_i2c.c:			     ts->screen_min_y, ts->screen_max_y, 0, 0);
ilitek_ts_i2c.c:	touchscreen_parse_properties(input, true, &ts->prop);
ilitek_ts_i2c.c:	error = input_mt_init_slots(input, ts->max_tp,
ilitek_ts_i2c.c:		dev_err(&ts->client->dev, "[%s] err:%d\n", __func__, error);
ilitek_ts_i2c.c:			 ts->firmware_ver[0], ts->firmware_ver[1],
ilitek_ts_i2c.c:			 ts->firmware_ver[2], ts->firmware_ver[3],
ilitek_ts_i2c.c:			 ts->firmware_ver[4], ts->firmware_ver[5],
ilitek_ts_i2c.c:			 ts->firmware_ver[6], ts->firmware_ver[7]);
ilitek_ts_i2c.c:			 ts->mcu_ver, ts->product_id);
ilitek_ts_i2c.c:	ts->client = client;
ilitek_ts_i2c.c:	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
ilitek_ts_i2c.c:	if (IS_ERR(ts->reset_gpio)) {
ilitek_ts_i2c.c:		error = PTR_ERR(ts->reset_gpio);
ilitek_ts_i2c.c:	error = devm_request_threaded_irq(dev, ts->client->irq,
ilitek_ts_i2c.c:		ilitek_reset(ts, ts->reset_time);
imagis.c:			.addr = ts->client->addr,
imagis.c:			.addr = ts->client->addr,
imagis.c:		ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
imagis.c:		dev_err(&ts->client->dev,
imagis.c:		dev_err(&ts->client->dev,
imagis.c:		dev_err(&ts->client->dev,
imagis.c:			dev_err(&ts->client->dev,
imagis.c:		input_mt_slot(ts->input_dev, i);
imagis.c:		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER,
imagis.c:		touchscreen_report_pos(ts->input_dev, &ts->prop,
imagis.c:		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
imagis.c:	input_mt_sync_frame(ts->input_dev);
imagis.c:	input_sync(ts->input_dev);
imagis.c:	regulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);
imagis.c:	error = regulator_bulk_enable(ARRAY_SIZE(ts->supplies), ts->supplies);
imagis.c:	enable_irq(ts->client->irq);
imagis.c:	disable_irq(ts->client->irq);
imagis.c:	input_dev = devm_input_allocate_device(&ts->client->dev);
imagis.c:	ts->input_dev = input_dev;
imagis.c:	touchscreen_parse_properties(input_dev, true, &ts->prop);
imagis.c:	if (!ts->prop.max_x || !ts->prop.max_y) {
imagis.c:		dev_err(&ts->client->dev,
imagis.c:		dev_err(&ts->client->dev,
imagis.c:		dev_err(&ts->client->dev,
imagis.c:	struct i2c_client *client = ts->client;
imagis.c:	ts->supplies[0].supply = "vdd";
imagis.c:	ts->supplies[1].supply = "vddio";
imagis.c:				       ARRAY_SIZE(ts->supplies),
imagis.c:				       ts->supplies);
imagis.c:	ts->client = i2c;
imagis.c:	mutex_lock(&ts->input_dev->mutex);
imagis.c:	if (input_device_enabled(ts->input_dev))
imagis.c:	mutex_unlock(&ts->input_dev->mutex);
imagis.c:	mutex_lock(&ts->input_dev->mutex);
imagis.c:	if (input_device_enabled(ts->input_dev))
imagis.c:	mutex_unlock(&ts->input_dev->mutex);
ipaq-micro-ts.c:		input_report_abs(ts->input, ABS_X,
ipaq-micro-ts.c:		input_report_abs(ts->input, ABS_Y,
ipaq-micro-ts.c:		input_report_key(ts->input, BTN_TOUCH, 1);
ipaq-micro-ts.c:		input_sync(ts->input);
ipaq-micro-ts.c:		input_report_abs(ts->input, ABS_X, 0);
ipaq-micro-ts.c:		input_report_abs(ts->input, ABS_Y, 0);
ipaq-micro-ts.c:		input_report_key(ts->input, BTN_TOUCH, 0);
ipaq-micro-ts.c:		input_sync(ts->input);
ipaq-micro-ts.c:	struct ipaq_micro *micro = ts->micro;
ipaq-micro-ts.c:	spin_unlock_irq(&ts->micro->lock);
ipaq-micro-ts.c:	ts->micro = micro;
ipaq-micro-ts.c:	ts->input = devm_input_allocate_device(&pdev->dev);
ipaq-micro-ts.c:	if (!ts->input) {
ipaq-micro-ts.c:	ts->input->name = "ipaq micro ts";
ipaq-micro-ts.c:	ts->input->open = micro_ts_open;
ipaq-micro-ts.c:	ts->input->close = micro_ts_close;
ipaq-micro-ts.c:	input_set_drvdata(ts->input, ts);
ipaq-micro-ts.c:	input_set_capability(ts->input, EV_KEY, BTN_TOUCH);
ipaq-micro-ts.c:	input_set_capability(ts->input, EV_ABS, ABS_X);
ipaq-micro-ts.c:	input_set_capability(ts->input, EV_ABS, ABS_Y);
ipaq-micro-ts.c:	input_set_abs_params(ts->input, ABS_X, 0, 1023, 0, 0);
ipaq-micro-ts.c:	input_set_abs_params(ts->input, ABS_Y, 0, 1023, 0, 0);
ipaq-micro-ts.c:	error = input_register_device(ts->input);
ipaq-micro-ts.c:	struct input_dev *input = ts->input;
jornada720_ts.c:	jornada_ts->x_data[0] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->x_data[1] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->x_data[2] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->y_data[0] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->y_data[1] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->y_data[2] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->x_data[3] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	jornada_ts->y_data[3] = jornada_ssp_byte(TXDUMMY);
jornada720_ts.c:	struct input_dev *input = jornada_ts->dev;
jornada720_ts.c:	if (gpiod_get_value(jornada_ts->gpio)) {
jornada720_ts.c:			x = jornada720_ts_average(jornada_ts->x_data);
jornada720_ts.c:			y = jornada720_ts_average(jornada_ts->y_data);
jornada720_ts.c:	jornada_ts->gpio = devm_gpiod_get(&pdev->dev, "penup", GPIOD_IN);
jornada720_ts.c:	if (IS_ERR(jornada_ts->gpio))
jornada720_ts.c:		return PTR_ERR(jornada_ts->gpio);
jornada720_ts.c:	irq = gpiod_to_irq(jornada_ts->gpio);
jornada720_ts.c:	jornada_ts->dev = input_dev;
jornada720_ts.c:	error = input_register_device(jornada_ts->dev);
lpc32xx_ts.c:#define MOD_NAME "ts-lpc32xx"
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:		res = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	u8 buf[sizeof(ts->fw_version)];
melfas_mip4.c:		memset(&ts->fw_version, 0xff, sizeof(ts->fw_version));
melfas_mip4.c:	mip4_parse_fw_version(buf, &ts->fw_version);
melfas_mip4.c:	if (i2c_smbus_xfer(ts->client->adapter, ts->client->addr,
melfas_mip4.c:		dev_err(&ts->client->dev, "nothing at this address\n");
melfas_mip4.c:			      ts->product_name, sizeof(ts->product_name));
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev, "product name: %.*s\n",
melfas_mip4.c:			(int)sizeof(ts->product_name), ts->product_name);
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		ts->product_id = get_unaligned_le16(&buf[0]);
melfas_mip4.c:		dev_dbg(&ts->client->dev, "product id: %04X\n", ts->product_id);
melfas_mip4.c:	snprintf(ts->fw_name, sizeof(ts->fw_name),
melfas_mip4.c:		"melfas_mip4_%04X.fw", ts->product_id);
melfas_mip4.c:	dev_dbg(&ts->client->dev, "firmware name: %s\n", ts->fw_name);
melfas_mip4.c:			      ts->ic_name, sizeof(ts->ic_name));
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev, "IC name: %.*s\n",
melfas_mip4.c:			(int)sizeof(ts->ic_name), ts->ic_name);
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev, "F/W Version: %04X %04X %04X %04X\n",
melfas_mip4.c:			 ts->fw_version.boot, ts->fw_version.core,
melfas_mip4.c:			 ts->fw_version.app, ts->fw_version.param);
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		ts->max_x = get_unaligned_le16(&buf[0]);
melfas_mip4.c:		ts->max_y = get_unaligned_le16(&buf[2]);
melfas_mip4.c:		dev_dbg(&ts->client->dev, "max_x: %d, max_y: %d\n",
melfas_mip4.c:			ts->max_x, ts->max_y);
melfas_mip4.c:		ts->node_x = buf[4];
melfas_mip4.c:		ts->node_y = buf[5];
melfas_mip4.c:		ts->node_key = buf[6];
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:			ts->node_x, ts->node_y, ts->node_key);
melfas_mip4.c:		ts->ppm_x = buf[12];
melfas_mip4.c:		ts->ppm_y = buf[13];
melfas_mip4.c:		dev_dbg(&ts->client->dev, "ppm_x: %d, ppm_y: %d\n",
melfas_mip4.c:			ts->ppm_x, ts->ppm_y);
melfas_mip4.c:		if (ts->node_key > 0)
melfas_mip4.c:			ts->key_num = ts->node_key;
melfas_mip4.c:		dev_warn(&ts->client->dev,
melfas_mip4.c:		ts->event_format = 0xff;
melfas_mip4.c:		ts->event_format = get_unaligned_le16(&buf[4]);
melfas_mip4.c:		ts->event_size = buf[6];
melfas_mip4.c:		dev_dbg(&ts->client->dev, "event_format: %d, event_size: %d\n",
melfas_mip4.c:			ts->event_format, ts->event_size);
melfas_mip4.c:		if (ts->event_format == 2 || ts->event_format > 3)
melfas_mip4.c:			dev_warn(&ts->client->dev,
melfas_mip4.c:				 "Unknown event format %d\n", ts->event_format);
melfas_mip4.c:	if (ts->gpio_ce) {
melfas_mip4.c:		gpiod_set_value_cansleep(ts->gpio_ce, 1);
melfas_mip4.c:	if (ts->gpio_ce)
melfas_mip4.c:		gpiod_set_value_cansleep(ts->gpio_ce, 0);
melfas_mip4.c:		input_mt_slot(ts->input, i);
melfas_mip4.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, 0);
melfas_mip4.c:	for (i = 0; i < ts->key_num; i++)
melfas_mip4.c:		input_report_key(ts->input, ts->key_code[i], 0);
melfas_mip4.c:	input_sync(ts->input);
melfas_mip4.c:	enable_irq(ts->client->irq);
melfas_mip4.c:	disable_irq(ts->client->irq);
melfas_mip4.c:	switch (ts->event_format) {
melfas_mip4.c:	if (key >= 1 && key <= ts->key_num) {
melfas_mip4.c:		unsigned short keycode = ts->key_code[key - 1];
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:		input_event(ts->input, EV_MSC, MSC_SCAN, keycode);
melfas_mip4.c:		input_report_key(ts->input, keycode, down);
melfas_mip4.c:		dev_err(&ts->client->dev, "Unknown key: %d\n", key);
melfas_mip4.c:	switch (ts->event_format) {
melfas_mip4.c:		if (ts->event_format == 0) {
melfas_mip4.c:	dev_dbg(&ts->client->dev,
melfas_mip4.c:		dev_err(&ts->client->dev, "Screen - invalid slot ID: %d\n", id);
melfas_mip4.c:		input_mt_slot(ts->input, id);
melfas_mip4.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
melfas_mip4.c:		input_report_abs(ts->input, ABS_MT_POSITION_X, x);
melfas_mip4.c:		input_report_abs(ts->input, ABS_MT_POSITION_Y, y);
melfas_mip4.c:		input_report_abs(ts->input, ABS_MT_PRESSURE, pressure);
melfas_mip4.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, touch_major);
melfas_mip4.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MINOR, touch_minor);
melfas_mip4.c:		input_mt_slot(ts->input, id);
melfas_mip4.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, 0);
melfas_mip4.c:	input_mt_sync_frame(ts->input);
melfas_mip4.c:	switch (ts->event_format) {
melfas_mip4.c:	dev_dbg(&ts->client->dev, "Type: %d\n", type);
melfas_mip4.c:		dev_err(&ts->client->dev, "Unknown event type: %d\n", type);
melfas_mip4.c:	struct i2c_client *client = ts->client;
melfas_mip4.c:	error = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, 1);
melfas_mip4.c:	size = ts->buf[0] & 0x7F;
melfas_mip4.c:	alert = ts->buf[0] & BIT(7);
melfas_mip4.c:	error = mip4_i2c_xfer(ts, cmd, sizeof(cmd), ts->buf, size);
melfas_mip4.c:		dev_dbg(&client->dev, "Alert: %d\n", ts->buf[0]);
melfas_mip4.c:		for (i = 0; i < size; i += ts->event_size) {
melfas_mip4.c:			error = mip4_handle_packet(ts, &ts->buf[i]);
melfas_mip4.c:		input_sync(ts->input);
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:		ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:			dev_dbg(&ts->client->dev, "%s - done\n", __func__);
melfas_mip4.c:			dev_err(&ts->client->dev, "Bootloader failure\n");
melfas_mip4.c:			dev_dbg(&ts->client->dev, "%s - Busy\n", __func__);
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:		ret = i2c_master_send(ts->client,
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:		ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:	ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	dev_dbg(&ts->client->dev,
melfas_mip4.c:	dev_dbg(&ts->client->dev, "Writing page @%#06x (%d)\n",
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 6);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 6);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:		ret = i2c_master_send(ts->client,
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 3);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:			.addr = ts->client->addr,
melfas_mip4.c:	dev_dbg(&ts->client->dev, "Validating page @%#06x (%d)\n",
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 6);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 6);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	ret = i2c_master_send(ts->client, cmd, 3);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:		dev_dbg(&ts->client->dev,
melfas_mip4.c:		ret = i2c_transfer(ts->client->adapter, msg, ARRAY_SIZE(msg));
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:			dev_err(&ts->client->dev,
melfas_mip4.c:	struct i2c_client *client = ts->client;
melfas_mip4.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);
melfas_mip4.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);
melfas_mip4.c:	input_set_abs_params(ts->input, ABS_X, 0, ts->max_x, 0, 0);
melfas_mip4.c:	input_set_abs_params(ts->input, ABS_Y, 0, ts->max_y, 0, 0);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_X, ts->ppm_x);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_Y, ts->ppm_y);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	dev_dbg(&ts->client->dev,
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	dev_dbg(&ts->client->dev,
melfas_mip4.c:	dev_dbg(&ts->client->dev, "F/W chip version: %04X %04X %04X %04X\n",
melfas_mip4.c:		 ts->fw_version.boot, ts->fw_version.core,
melfas_mip4.c:		 ts->fw_version.app, ts->fw_version.param);
melfas_mip4.c:		dev_dbg(&ts->client->dev, "F/W type: Bootloader\n");
melfas_mip4.c:		dev_dbg(&ts->client->dev, "F/W type: Main\n");
melfas_mip4.c:		dev_err(&ts->client->dev, "Wrong firmware type\n");
melfas_mip4.c:	if (ts->input->users) {
melfas_mip4.c:		disable_irq(ts->client->irq);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	if (ts->input->users)
melfas_mip4.c:		enable_irq(ts->client->irq);
melfas_mip4.c:	error = request_firmware(&fw, ts->fw_name, dev);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:			ts->fw_name, error);
melfas_mip4.c:	mutex_lock(&ts->input->mutex);
melfas_mip4.c:	mutex_unlock(&ts->input->mutex);
melfas_mip4.c:		dev_err(&ts->client->dev,
melfas_mip4.c:	mutex_lock(&ts->input->mutex);
melfas_mip4.c:			 ts->fw_version.boot, ts->fw_version.core,
melfas_mip4.c:			 ts->fw_version.app, ts->fw_version.param);
melfas_mip4.c:	mutex_unlock(&ts->input->mutex);
melfas_mip4.c:	mutex_lock(&ts->input->mutex);
melfas_mip4.c:			 (int)sizeof(ts->product_name), ts->product_name);
melfas_mip4.c:	mutex_unlock(&ts->input->mutex);
melfas_mip4.c:	mutex_lock(&ts->input->mutex);
melfas_mip4.c:	count = snprintf(buf, PAGE_SIZE, "%04X\n", ts->product_id);
melfas_mip4.c:	mutex_unlock(&ts->input->mutex);
melfas_mip4.c:	mutex_lock(&ts->input->mutex);
melfas_mip4.c:			 (int)sizeof(ts->ic_name), ts->ic_name);
melfas_mip4.c:	mutex_unlock(&ts->input->mutex);
melfas_mip4.c:	sysfs_remove_group(&ts->client->dev.kobj, &mip4_attr_group);
melfas_mip4.c:	ts->client = client;
melfas_mip4.c:	ts->input = input;
melfas_mip4.c:	snprintf(ts->phys, sizeof(ts->phys),
melfas_mip4.c:	ts->gpio_ce = devm_gpiod_get_optional(&client->dev,
melfas_mip4.c:	if (IS_ERR(ts->gpio_ce)) {
melfas_mip4.c:		error = PTR_ERR(ts->gpio_ce);
melfas_mip4.c:	input->phys = ts->phys;
melfas_mip4.c:	input->id.product = ts->product_id;
melfas_mip4.c:	input->keycode = ts->key_code;
melfas_mip4.c:	input->keycodesize = sizeof(*ts->key_code);
melfas_mip4.c:	input->keycodemax = ts->key_num;
melfas_mip4.c:	input_set_abs_params(input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);
melfas_mip4.c:	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->ppm_x);
melfas_mip4.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->ppm_y);
melfas_mip4.c:	struct input_dev *input = ts->input;
melfas_mip4.c:		ts->wake_irq_enabled = enable_irq_wake(client->irq) == 0;
melfas_mip4.c:	struct input_dev *input = ts->input;
melfas_mip4.c:	if (ts->wake_irq_enabled)
mxs-lradc-ts.c:	return !!(readl(ts->base + LRADC_STATUS) &
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL4 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL4 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	       LRADC_CH_NUM_SAMPLES(ts->over_sample_cnt - 1),
mxs-lradc-ts.c:	       ts->base + LRADC_CH(ch));
mxs-lradc-ts.c:	       ts->base + LRADC_CH(ch) + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       LRADC_DELAY_LOOP(ts->over_sample_cnt - 1) |
mxs-lradc-ts.c:	       LRADC_DELAY_DELAY(ts->over_sample_delay - 1),
mxs-lradc-ts.c:	       ts->base + LRADC_DELAY(3));
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       LRADC_DELAY_KICK | LRADC_DELAY_DELAY(ts->settling_delay),
mxs-lradc-ts.c:	       ts->base + LRADC_DELAY(2));
mxs-lradc-ts.c:		LRADC_CH_NUM_SAMPLES(ts->over_sample_cnt - 1);
mxs-lradc-ts.c:	writel(reg, ts->base + LRADC_CH(ch1));
mxs-lradc-ts.c:	writel(reg, ts->base + LRADC_CH(ch2));
mxs-lradc-ts.c:	       ts->base + LRADC_CH(ch1) + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CH(ch2) + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       LRADC_DELAY_LOOP(ts->over_sample_cnt - 1) |
mxs-lradc-ts.c:	       LRADC_DELAY_DELAY(ts->over_sample_delay - 1),
mxs-lradc-ts.c:	       ts->base + LRADC_DELAY(3));
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       LRADC_DELAY_KICK | LRADC_DELAY_DELAY(ts->settling_delay),
mxs-lradc-ts.c:	       ts->base + LRADC_DELAY(2));
mxs-lradc-ts.c:	reg = readl(ts->base + LRADC_CH(channel));
mxs-lradc-ts.c:		num_samples = ts->over_sample_cnt;
mxs-lradc-ts.c:	reg = readl(ts->base + LRADC_CTRL1) & mask;
mxs-lradc-ts.c:		reg = readl(ts->base + LRADC_CTRL1) & mask;
mxs-lradc-ts.c:		dev_dbg(ts->dev, "One channel is still busy: %X\n", reg);
mxs-lradc-ts.c:		dev_warn(ts->dev, "Cannot calculate pressure\n");
mxs-lradc-ts.c:	dev_dbg(ts->dev, "Pressure = %u\n", pressure);
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	ts->cur_plate = LRADC_SAMPLE_X;
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	ts->cur_plate = LRADC_SAMPLE_Y;
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	ts->cur_plate = LRADC_SAMPLE_PRESSURE;
mxs-lradc-ts.c:	ts->cur_plate = LRADC_TOUCH;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	input_report_abs(ts->ts_input, ABS_X, ts->ts_x_pos);
mxs-lradc-ts.c:	input_report_abs(ts->ts_input, ABS_Y, ts->ts_y_pos);
mxs-lradc-ts.c:	input_report_abs(ts->ts_input, ABS_PRESSURE, ts->ts_pressure);
mxs-lradc-ts.c:	input_report_key(ts->ts_input, BTN_TOUCH, 1);
mxs-lradc-ts.c:	input_sync(ts->ts_input);
mxs-lradc-ts.c:	ts->cur_plate = LRADC_SAMPLE_VALID;
mxs-lradc-ts.c:	writel(0, ts->base + LRADC_CH(TOUCHSCREEN_VCHANNEL1));
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_DELAY(2));
mxs-lradc-ts.c:		ts->ts_valid = true;
mxs-lradc-ts.c:	if (ts->ts_valid) {
mxs-lradc-ts.c:		ts->ts_valid = false;
mxs-lradc-ts.c:		input_report_key(ts->ts_input, BTN_TOUCH, 0);
mxs-lradc-ts.c:		input_sync(ts->ts_input);
mxs-lradc-ts.c:	ts->cur_plate = LRADC_TOUCH;
mxs-lradc-ts.c:	writel(0, ts->base + LRADC_DELAY(2));
mxs-lradc-ts.c:	writel(0, ts->base + LRADC_DELAY(3));
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	switch (ts->cur_plate) {
mxs-lradc-ts.c:		       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:		ts->ts_y_pos =
mxs-lradc-ts.c:		ts->ts_x_pos =
mxs-lradc-ts.c:		ts->ts_pressure =
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	unsigned long reg = readl(ts->base + LRADC_CTRL1);
mxs-lradc-ts.c:		spin_lock_irqsave(&ts->lock, flags);
mxs-lradc-ts.c:		spin_unlock_irqrestore(&ts->lock, flags);
mxs-lradc-ts.c:		       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:	       ts->base + LRADC_CTRL1 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:		writel(0, ts->base + LRADC_DELAY(i));
mxs-lradc-ts.c:	struct mxs_lradc *lradc = ts->lradc;
mxs-lradc-ts.c:		       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_CLR);
mxs-lradc-ts.c:			       ts->base + LRADC_CTRL0 + STMP_OFFSET_REG_SET);
mxs-lradc-ts.c:	struct input_dev *input = ts->ts_input;
mxs-lradc-ts.c:	struct device *dev = ts->dev;
mxs-lradc-ts.c:	ts->ts_input = input;
mxs-lradc-ts.c:	ts->lradc = lradc;
mxs-lradc-ts.c:	ts->dev = dev;
mxs-lradc-ts.c:	spin_lock_init(&ts->lock);
mxs-lradc-ts.c:	ts->base = devm_ioremap(dev, iores->start, resource_size(iores));
mxs-lradc-ts.c:	if (!ts->base)
mxs-lradc-ts.c:		ts->over_sample_cnt = 4;
mxs-lradc-ts.c:			ts->over_sample_cnt = adapt;
mxs-lradc-ts.c:			dev_err(ts->dev, "Invalid sample count (%u)\n",
mxs-lradc-ts.c:		ts->over_sample_delay = 2;
mxs-lradc-ts.c:			ts->over_sample_delay = adapt;
mxs-lradc-ts.c:			dev_err(ts->dev, "Invalid sample delay (%u)\n",
mxs-lradc-ts.c:		ts->settling_delay = 10;
mxs-lradc-ts.c:			ts->settling_delay = adapt;
mxs-lradc-ts.c:			dev_err(ts->dev, "Invalid settling delay (%u)\n",
mxs-lradc-ts.c:	ret = stmp_reset_block(ts->base);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->xbuf_lock);
nt36xxx/nt36xxx.c:	msgs[1].buf   = ts->xbuf;
nt36xxx/nt36xxx.c:	memcpy(buf + 1, ts->xbuf, len - 1);
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->xbuf_lock);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->xbuf_lock);
nt36xxx/nt36xxx.c:	memcpy(ts->xbuf, buf, len);
nt36xxx/nt36xxx.c:	msg.buf   = ts->xbuf;
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->xbuf_lock);
nt36xxx/nt36xxx.c:	CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx.c:		buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx.c:		buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx.c:		buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx.c:		buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 6);
nt36xxx/nt36xxx.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx.c:	ts->nvt_pid = (buf[2] << 8) + buf[1];
nt36xxx/nt36xxx.c:	NVT_LOG("PID=%04X\n", ts->nvt_pid);
nt36xxx/nt36xxx.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 17);
nt36xxx/nt36xxx.c:	ts->fw_ver = buf[1];
nt36xxx/nt36xxx.c:	ts->x_num = buf[3];
nt36xxx/nt36xxx.c:	ts->y_num = buf[4];
nt36xxx/nt36xxx.c:	ts->abs_x_max = (uint16_t)((buf[5] << 8) | buf[6]);
nt36xxx/nt36xxx.c:	ts->abs_y_max = (uint16_t)((buf[7] << 8) | buf[8]);
nt36xxx/nt36xxx.c:	ts->max_button_num = buf[11];
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->fw_ver=%d\n", __func__,ts->fw_ver);
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->x_num=%d\n", __func__,ts->x_num);
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->y_num=%d\n", __func__,ts->y_num);
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->abs_x_max=%d\n", __func__,ts->abs_x_max);
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->abs_y_max=%d\n", __func__,ts->abs_y_max);
nt36xxx/nt36xxx.c:	NVT_ERR("%s:ts->max_button_num=%d\n", __func__,ts->max_button_num);
nt36xxx/nt36xxx.c:		ts->fw_ver = 0;
nt36xxx/nt36xxx.c:		ts->x_num = 18;
nt36xxx/nt36xxx.c:		ts->y_num = 32;
nt36xxx/nt36xxx.c:		ts->abs_x_max = TOUCH_DEFAULT_MAX_WIDTH;
nt36xxx/nt36xxx.c:		ts->abs_y_max = TOUCH_DEFAULT_MAX_HEIGHT;
nt36xxx/nt36xxx.c:		ts->max_button_num = TOUCH_KEY_NUM;
nt36xxx/nt36xxx.c:					ts->fw_ver, ts->x_num, ts->y_num,
nt36xxx/nt36xxx.c:					ts->abs_x_max, ts->abs_y_max, ts->max_button_num);
nt36xxx/nt36xxx.c:			ret = CTP_I2C_WRITE(ts->client, (str[0] & 0x7F), &str[2], str[1]);
nt36xxx/nt36xxx.c:			ret = CTP_I2C_READ(ts->client, (str[0] & 0x7F), &str[2], str[1]);
nt36xxx/nt36xxx.c:			ts->dbclick_count++;
nt36xxx/nt36xxx.c:			snprintf(ch, sizeof(ch), "%d", ts->dbclick_count);
nt36xxx/nt36xxx.c:		input_report_key(ts->input_dev, keycode, 1);
nt36xxx/nt36xxx.c:		input_sync(ts->input_dev);
nt36xxx/nt36xxx.c:		input_report_key(ts->input_dev, keycode, 0);
nt36xxx/nt36xxx.c:		input_sync(ts->input_dev);
nt36xxx/nt36xxx.c:	ts->irq_gpio = of_get_named_gpio_flags(np, "novatek,irq-gpio", 0, &ts->irq_flags);
nt36xxx/nt36xxx.c:	NVT_LOG("novatek,irq-gpio=%d\n", ts->irq_gpio);
nt36xxx/nt36xxx.c:	ts->reset_gpio = of_get_named_gpio_flags(np, "novatek,reset-gpio", 0, NULL);
nt36xxx/nt36xxx.c:	NVT_LOG("novatek,reset-gpio=%d\n", ts->reset_gpio);
nt36xxx/nt36xxx.c:	ts->reset_tddi = of_get_named_gpio_flags(np, "novatek,reset-tddi", 0, NULL);
nt36xxx/nt36xxx.c:	NVT_LOG("novatek,reset-tddi=%d\n", ts->reset_tddi);
nt36xxx/nt36xxx.c:		ts->vddio_reg_name = NULL;
nt36xxx/nt36xxx.c:		ts->vddio_reg_name = name;
nt36xxx/nt36xxx.c:		ts->lab_reg_name = NULL;
nt36xxx/nt36xxx.c:		ts->lab_reg_name = name;
nt36xxx/nt36xxx.c:		ts->ibb_reg_name = NULL;
nt36xxx/nt36xxx.c:		ts->ibb_reg_name = name;
nt36xxx/nt36xxx.c:	ts->dump_click_count =
nt36xxx/nt36xxx.c:				 (u32 *) & ts->config_array_size);
nt36xxx/nt36xxx.c:	ts->config_array = devm_kzalloc(dev, ts->config_array_size *
nt36xxx/nt36xxx.c:	if (!ts->config_array) {
nt36xxx/nt36xxx.c:	config_info = ts->config_array;
nt36xxx/nt36xxx.c:		if (ts->dump_click_count) {
nt36xxx/nt36xxx.c:	ts->irq_gpio = NVTTOUCH_INT_PIN;
nt36xxx/nt36xxx.c:	for (i = 0; i < ts->config_array_size; i++) {
nt36xxx/nt36xxx.c:		NVT_LOG("lockdown_info[0] = %d config_array[%d].tp_vendor = %d\n",ts->lockdown_info[0],i,ts->config_array[i].tp_vendor);	
nt36xxx/nt36xxx.c:		NVT_LOG("lockdown_info[3] = %d config_array[%d].tp_hw_version = %d\n",ts->lockdown_info[3],i,ts->config_array[i].tp_hw_version);
nt36xxx/nt36xxx.c:		if ((ts->lockdown_info[0] ==
nt36xxx/nt36xxx.c:		     ts->config_array[i].tp_vendor) &&
nt36xxx/nt36xxx.c:		     (ts->lockdown_info[3] ==
nt36xxx/nt36xxx.c:		     ts->config_array[i].tp_hw_version))
nt36xxx/nt36xxx.c:	if (i >= ts->config_array_size) {
nt36xxx/nt36xxx.c:		 ts->config_array[i].nvt_cfg_name);
nt36xxx/nt36xxx.c:	ts->current_index = i;
nt36xxx/nt36xxx.c:	if (ts->dump_click_count) {
nt36xxx/nt36xxx.c:		ts->current_clicknum_file =
nt36xxx/nt36xxx.c:		strlcpy(ts->current_clicknum_file,
nt36xxx/nt36xxx.c:			ts->config_array[i].clicknum_file_name,
nt36xxx/nt36xxx.c:		//add_hw_monitor_info(HWMON_CONPONENT_NAME, "tpvendor", ts->current_clicknum_file);
nt36xxx/nt36xxx.c:	return ts->config_array[i].nvt_cfg_name;
nt36xxx/nt36xxx.c:	if ((ts->vddio_reg_name != NULL) && (*ts->vddio_reg_name != 0)) {
nt36xxx/nt36xxx.c:		ts->vddio_reg = regulator_get(&ts->client->dev,
nt36xxx/nt36xxx.c:				ts->vddio_reg_name);
nt36xxx/nt36xxx.c:		if (IS_ERR(ts->vddio_reg)) {
nt36xxx/nt36xxx.c:			retval = PTR_ERR(ts->vddio_reg);
nt36xxx/nt36xxx.c:	if ((ts->lab_reg_name != NULL) && (*ts->lab_reg_name != 0)) {
nt36xxx/nt36xxx.c:		ts->lab_reg = regulator_get(&ts->client->dev,
nt36xxx/nt36xxx.c:				ts->lab_reg_name);
nt36xxx/nt36xxx.c:		if (IS_ERR(ts->lab_reg)) {
nt36xxx/nt36xxx.c:			retval = PTR_ERR(ts->lab_reg);
nt36xxx/nt36xxx.c:	if ((ts->ibb_reg_name != NULL) && (*ts->ibb_reg_name != 0)) {
nt36xxx/nt36xxx.c:		ts->ibb_reg = regulator_get(&ts->client->dev,
nt36xxx/nt36xxx.c:				ts->ibb_reg_name);
nt36xxx/nt36xxx.c:		if (IS_ERR(ts->ibb_reg)) {
nt36xxx/nt36xxx.c:			retval = PTR_ERR(ts->ibb_reg);
nt36xxx/nt36xxx.c:	if (ts->vddio_reg) {
nt36xxx/nt36xxx.c:		regulator_put(ts->vddio_reg);
nt36xxx/nt36xxx.c:		ts->vddio_reg = NULL;
nt36xxx/nt36xxx.c:	if (ts->lab_reg) {
nt36xxx/nt36xxx.c:		regulator_put(ts->lab_reg);
nt36xxx/nt36xxx.c:		ts->lab_reg = NULL;
nt36xxx/nt36xxx.c:	if (ts->ibb_reg) {
nt36xxx/nt36xxx.c:		regulator_put(ts->ibb_reg);
nt36xxx/nt36xxx.c:		ts->ibb_reg = NULL;
nt36xxx/nt36xxx.c:	if (ts->vddio_reg) {
nt36xxx/nt36xxx.c:		retval = regulator_enable(ts->vddio_reg);
nt36xxx/nt36xxx.c:	if (ts->lab_reg && ts->lab_reg) {
nt36xxx/nt36xxx.c:		retval = regulator_enable(ts->lab_reg);
nt36xxx/nt36xxx.c:	if (ts->ibb_reg) {
nt36xxx/nt36xxx.c:		retval = regulator_enable(ts->ibb_reg);
nt36xxx/nt36xxx.c:	if (ts->ibb_reg)
nt36xxx/nt36xxx.c:		regulator_disable(ts->ibb_reg);
nt36xxx/nt36xxx.c:	if (ts->lab_reg)
nt36xxx/nt36xxx.c:		regulator_disable(ts->lab_reg);
nt36xxx/nt36xxx.c:	if (ts->vddio_reg)
nt36xxx/nt36xxx.c:		regulator_disable(ts->vddio_reg);
nt36xxx/nt36xxx.c:	if (gpio_is_valid(ts->irq_gpio)) {
nt36xxx/nt36xxx.c:		ret = gpio_request_one(ts->irq_gpio, GPIOF_IN, "NVT-int");
nt36xxx/nt36xxx.c:	if (gpio_is_valid(ts->reset_gpio)) {
nt36xxx/nt36xxx.c:		ret = gpio_request_one(ts->reset_gpio, GPIOF_OUT_INIT_HIGH, "NVT-reset");
nt36xxx/nt36xxx.c:		gpio_direction_output(ts->reset_gpio, 1);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->lock);
nt36xxx/nt36xxx.c:	if (ts->dev_pm_suspend) {
nt36xxx/nt36xxx.c:		ret = wait_for_completion_timeout(&ts->dev_pm_suspend_completion, msecs_to_jiffies(500));
nt36xxx/nt36xxx.c:	ret = CTP_I2C_READ(ts->client, I2C_FW_Address, point_data, POINT_DATA_LEN + 1);
nt36xxx/nt36xxx.c:		enable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx.c:	for (i = 0; i < ts->max_touch_num; i++) {
nt36xxx/nt36xxx.c:		if ((input_id == 0) || (input_id > ts->max_touch_num))
nt36xxx/nt36xxx.c:			if ((input_x > ts->abs_x_max) || (input_y > ts->abs_y_max))
nt36xxx/nt36xxx.c:			input_mt_slot(ts->input_dev, input_id - 1);
nt36xxx/nt36xxx.c:			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, input_id - 1);
nt36xxx/nt36xxx.c:			input_report_key(ts->input_dev, BTN_TOUCH, 1);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, input_p);
nt36xxx/nt36xxx.c:			input_mt_sync(ts->input_dev);
nt36xxx/nt36xxx.c:	for (i = 0; i < ts->max_touch_num; i++) {
nt36xxx/nt36xxx.c:			input_mt_slot(ts->input_dev, i);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
nt36xxx/nt36xxx.c:			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
nt36xxx/nt36xxx.c:			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
nt36xxx/nt36xxx.c:	input_report_key(ts->input_dev, BTN_TOUCH, (finger_cnt > 0));
nt36xxx/nt36xxx.c:		input_report_key(ts->input_dev, BTN_TOUCH, 0);
nt36xxx/nt36xxx.c:		input_mt_sync(ts->input_dev);
nt36xxx/nt36xxx.c:		for (i = 0; i < ts->max_button_num; i++) {
nt36xxx/nt36xxx.c:			input_report_key(ts->input_dev, touch_key_array[i], ((point_data[62] >> i) & 0x01));
nt36xxx/nt36xxx.c:		for (i = 0; i < ts->max_button_num; i++) {
nt36xxx/nt36xxx.c:			input_report_key(ts->input_dev, touch_key_array[i], 0);
nt36xxx/nt36xxx.c:	input_sync(ts->input_dev);
nt36xxx/nt36xxx.c:	enable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx.c:	disable_irq_nosync(ts->client->irq);
nt36xxx/nt36xxx.c:		dev_dbg(&ts->client->dev, "%s gesture wakeup\n", __func__);
nt36xxx/nt36xxx.c:	queue_work(nvt_wq, &ts->nvt_work);
nt36xxx/nt36xxx.c:	CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx.c:	CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 4);
nt36xxx/nt36xxx.c:			CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx.c:			CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx.c:			CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx.c:			CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 2);
nt36xxx/nt36xxx.c:			CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx.c:			CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 2);
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx.c:		CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 7);
nt36xxx/nt36xxx.c:				ts->mmap = trim_id_table[list].mmap;
nt36xxx/nt36xxx.c:				ts->carrier_system = trim_id_table[list].carrier_system;
nt36xxx/nt36xxx.c:				ts->mmap = NULL;
nt36xxx/nt36xxx.c:		disable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:		enable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:	return snprintf(buf, PAGE_SIZE, "%c\n", ts->lockdown_info[2]);
nt36xxx/nt36xxx.c:	return snprintf(buf, PAGE_SIZE, "%c\n", ts->lockdown_info[6]);
nt36xxx/nt36xxx.c:	return snprintf(buf, PAGE_SIZE, "%c\n", ts->lockdown_info[1]);
nt36xxx/nt36xxx.c:	ts->client = client;
nt36xxx/nt36xxx.c:	/*---parse dts---*/
nt36xxx/nt36xxx.c:	if (!ret && ts->ts_pinctrl) {
nt36xxx/nt36xxx.c:		ret = pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_active);
nt36xxx/nt36xxx.c:	mutex_init(&ts->xbuf_lock);
nt36xxx/nt36xxx.c:	mutex_init(&ts->mdata_lock);
nt36xxx/nt36xxx.c:	mutex_init(&ts->lock);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->lock);
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx.c:	INIT_WORK(&ts->nvt_work, nvt_ts_work_func);
nt36xxx/nt36xxx.c:	ts->input_dev = input_allocate_device();
nt36xxx/nt36xxx.c:	if (ts->input_dev == NULL) {
nt36xxx/nt36xxx.c:	ts->max_touch_num = TOUCH_MAX_FINGER_NUM;
nt36xxx/nt36xxx.c:	ts->max_button_num = TOUCH_KEY_NUM;
nt36xxx/nt36xxx.c:	ts->int_trigger_type = INT_TRIGGER_TYPE;
nt36xxx/nt36xxx.c:	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
nt36xxx/nt36xxx.c:	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
nt36xxx/nt36xxx.c:	ts->input_dev->propbit[0] = BIT(INPUT_PROP_DIRECT);
nt36xxx/nt36xxx.c:	input_mt_init_slots(ts->input_dev, ts->max_touch_num, 0);
nt36xxx/nt36xxx.c:	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, TOUCH_FORCE_NUM, 0, 0);    /*pressure = TOUCH_FORCE_NUM*/
nt36xxx/nt36xxx.c:	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);	  /*area = 255*/
nt36xxx/nt36xxx.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max - 1, 0, 0);
nt36xxx/nt36xxx.c:	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max - 1, 0, 0);
nt36xxx/nt36xxx.c:	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, ts->max_touch_num, 0, 0);
nt36xxx/nt36xxx.c:	for (retry = 0; retry < ts->max_button_num; retry++) {
nt36xxx/nt36xxx.c:		input_set_capability(ts->input_dev, EV_KEY, touch_key_array[retry]);
nt36xxx/nt36xxx.c:		input_set_capability(ts->input_dev, EV_KEY, gesture_key_array[retry]);
nt36xxx/nt36xxx.c:	sprintf(ts->phys, "input/ts");
nt36xxx/nt36xxx.c:	ts->input_dev->name = NVT_TS_NAME;
nt36xxx/nt36xxx.c:	ts->input_dev->phys = ts->phys;
nt36xxx/nt36xxx.c:	ts->input_dev->id.bustype = BUS_I2C;
nt36xxx/nt36xxx.c:	ts->input_dev->event = nvt_input_event;
nt36xxx/nt36xxx.c:	input_set_drvdata(ts->input_dev, ts);
nt36xxx/nt36xxx.c:	ret = input_register_device(ts->input_dev);
nt36xxx/nt36xxx.c:		NVT_ERR("register input device (%s) failed. ret=%d\n", ts->input_dev->name, ret);
nt36xxx/nt36xxx.c:	client->irq = gpio_to_irq(ts->irq_gpio);
nt36xxx/nt36xxx.c:		NVT_LOG("int_trigger_type=%d\n", ts->int_trigger_type);
nt36xxx/nt36xxx.c:		ret = request_irq(client->irq, nvt_ts_irq_handler, ts->int_trigger_type | IRQF_ONESHOT, client->name, ts);
nt36xxx/nt36xxx.c:		ret = request_irq(client->irq, nvt_ts_irq_handler, ts->int_trigger_type, client->name, ts);
nt36xxx/nt36xxx.c:	ret = nvt_get_lockdown_info(ts->lockdown_info);
nt36xxx/nt36xxx.c:				ts->lockdown_info[0], ts->lockdown_info[1], ts->lockdown_info[2], ts->lockdown_info[3],
nt36xxx/nt36xxx.c:				ts->lockdown_info[4], ts->lockdown_info[5], ts->lockdown_info[6], ts->lockdown_info[7]);
nt36xxx/nt36xxx.c:		//update_hardware_info(TYPE_TP_MAKER, ts->lockdown_info[0] - 0x30);
nt36xxx/nt36xxx.c:	ts->fw_name = nvt_get_config(ts);
nt36xxx/nt36xxx.c:		//strlcpy(tp_maker, update_hw_component_touch_module_info(ts->lockdown_info[0]), 20);
nt36xxx/nt36xxx.c:	ts->dbclick_count = 0;
nt36xxx/nt36xxx.c:	ts->dev_pm_suspend = false;
nt36xxx/nt36xxx.c:	init_completion(&ts->dev_pm_suspend_completion);
nt36xxx/nt36xxx.c:	INIT_DELAYED_WORK(&ts->nvt_fwu_work, Boot_Update_Firmware);
nt36xxx/nt36xxx.c:	queue_delayed_work(nvt_fwu_wq, &ts->nvt_fwu_work, msecs_to_jiffies(14000));
nt36xxx/nt36xxx.c:	ts->notifier.notifier_call = drm_notifier_callback;
nt36xxx/nt36xxx.c:	ret = drm_register_client(&ts->notifier);
nt36xxx/nt36xxx.c:	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
nt36xxx/nt36xxx.c:	ts->early_suspend.suspend = nvt_ts_early_suspend;
nt36xxx/nt36xxx.c:	ts->early_suspend.resume = nvt_ts_late_resume;
nt36xxx/nt36xxx.c:	ret = register_early_suspend(&ts->early_suspend);
nt36xxx/nt36xxx.c:	ts->attrs.attrs = nvt_attr_group;
nt36xxx/nt36xxx.c:	ret = sysfs_create_group(&client->dev.kobj, &ts->attrs);
nt36xxx/nt36xxx.c:	if (ts->nvt_tp_class == NULL)
nt36xxx/nt36xxx.c:		ts->nvt_tp_class = class_create(THIS_MODULE, "touch");
nt36xxx/nt36xxx.c:	ts->nvt_touch_dev = device_create(ts->nvt_tp_class, NULL, 0x62, ts, "touch_suspend_notify");
nt36xxx/nt36xxx.c:	if (IS_ERR(ts->nvt_touch_dev)) {
nt36xxx/nt36xxx.c:	dev_set_drvdata(ts->nvt_touch_dev, ts);
nt36xxx/nt36xxx.c:	ret = sysfs_create_file(&ts->nvt_touch_dev->kobj, &dev_attr_touch_suspend_notify.attr);
nt36xxx/nt36xxx.c:	ts->event_wq = alloc_workqueue("nvt-event-queue",
nt36xxx/nt36xxx.c:	if (!ts->event_wq) {
nt36xxx/nt36xxx.c:	INIT_WORK(&ts->resume_work, nvt_resume_work);
nt36xxx/nt36xxx.c:	ts->debugfs = debugfs_create_dir("tp_debug", NULL);
nt36xxx/nt36xxx.c:	if (ts->debugfs) {
nt36xxx/nt36xxx.c:		debugfs_create_file("switch_state", 0660, ts->debugfs, ts, &tpdbg_operations);
nt36xxx/nt36xxx.c:	destroy_workqueue(ts->event_wq);
nt36xxx/nt36xxx.c:	device_destroy(ts->nvt_tp_class, 0x62);
nt36xxx/nt36xxx.c:	class_destroy(ts->nvt_tp_class);
nt36xxx/nt36xxx.c:	ts->nvt_tp_class = NULL;
nt36xxx/nt36xxx.c:	drm_unregister_client(&ts->notifier);
nt36xxx/nt36xxx.c:	input_free_device(ts->input_dev);
nt36xxx/nt36xxx.c:	mutex_destroy(&ts->lock);
nt36xxx/nt36xxx.c:	gpio_free(ts->irq_gpio);
nt36xxx/nt36xxx.c:	if (gpio_is_valid(ts->reset_gpio))
nt36xxx/nt36xxx.c:		gpio_free(ts->reset_gpio);
nt36xxx/nt36xxx.c:	if (drm_unregister_client(&ts->notifier))
nt36xxx/nt36xxx.c:	unregister_early_suspend(&ts->early_suspend);
nt36xxx/nt36xxx.c:	if (ts->dump_click_count && !ts->current_clicknum_file) {
nt36xxx/nt36xxx.c:		kfree(ts->current_clicknum_file);
nt36xxx/nt36xxx.c:		ts->current_clicknum_file = NULL;
nt36xxx/nt36xxx.c:	sysfs_remove_file(&ts->nvt_touch_dev->kobj,
nt36xxx/nt36xxx.c:	device_destroy(ts->nvt_tp_class, 0x62);
nt36xxx/nt36xxx.c:	class_destroy(ts->nvt_tp_class);
nt36xxx/nt36xxx.c:	ts->nvt_tp_class = NULL;
nt36xxx/nt36xxx.c:	destroy_workqueue(ts->event_wq);
nt36xxx/nt36xxx.c:	mutex_destroy(&ts->lock);
nt36xxx/nt36xxx.c:	input_unregister_device(ts->input_dev);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->lock);
nt36xxx/nt36xxx.c:	if (ts->gesture_enabled) {
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 4);
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx.c:		disable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx.c:		if (ts->ts_pinctrl) {
nt36xxx/nt36xxx.c:			ret = pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_suspend);
nt36xxx/nt36xxx.c:	for (i = 0; i < ts->max_touch_num; i++) {
nt36xxx/nt36xxx.c:		input_mt_slot(ts->input_dev, i);
nt36xxx/nt36xxx.c:		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
nt36xxx/nt36xxx.c:		input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
nt36xxx/nt36xxx.c:		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
nt36xxx/nt36xxx.c:	input_report_key(ts->input_dev, BTN_TOUCH, 0);
nt36xxx/nt36xxx.c:	input_mt_sync(ts->input_dev);
nt36xxx/nt36xxx.c:	input_sync(ts->input_dev);
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx.c:	mutex_lock(&ts->lock);
nt36xxx/nt36xxx.c:	gpio_direction_output(ts->reset_gpio, 1);
nt36xxx/nt36xxx.c:	gpio_direction_output(ts->reset_gpio, 0);
nt36xxx/nt36xxx.c:	gpio_direction_output(ts->reset_gpio, 1);
nt36xxx/nt36xxx.c:	NVT_LOG("gesture_enabled= %d\n",ts->gesture_enabled);
nt36xxx/nt36xxx.c:	if (!ts->gesture_enabled) {
nt36xxx/nt36xxx.c:		enable_irq(ts->client->irq);
nt36xxx/nt36xxx.c:		if (ts->ts_pinctrl) {
nt36xxx/nt36xxx.c:			ret = pinctrl_select_state(ts->ts_pinctrl, ts->pinctrl_state_active);
nt36xxx/nt36xxx.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx.c:	nvt_ts_resume(&ts->client->dev);
nt36xxx/nt36xxx.c:			if (ts->gesture_enabled) {
nt36xxx/nt36xxx.c:			flush_workqueue(ts->event_wq);
nt36xxx/nt36xxx.c:			nvt_ts_suspend(&ts->client->dev);
nt36xxx/nt36xxx.c:			sysfs_notify(&ts->nvt_touch_dev->kobj, NULL,
nt36xxx/nt36xxx.c:			if (ts->gesture_enabled) {
nt36xxx/nt36xxx.c:				gpio_direction_output(ts->reset_tddi, 0);
nt36xxx/nt36xxx.c:				gpio_direction_output(ts->reset_tddi, 1);
nt36xxx/nt36xxx.c:			if (ts->gesture_enabled) {
nt36xxx/nt36xxx.c:			flush_workqueue(ts->event_wq);
nt36xxx/nt36xxx.c:			queue_work(ts->event_wq, &ts->resume_work);
nt36xxx/nt36xxx.c:			sysfs_notify(&ts->nvt_touch_dev->kobj, NULL,
nt36xxx/nt36xxx.c:	if (device_may_wakeup(dev) && ts->gesture_enabled) {
nt36xxx/nt36xxx.c:		enable_irq_wake(ts->client->irq);
nt36xxx/nt36xxx.c:	ts->dev_pm_suspend = true;
nt36xxx/nt36xxx.c:	reinit_completion(&ts->dev_pm_suspend_completion);
nt36xxx/nt36xxx.c:	if (device_may_wakeup(dev) && ts->gesture_enabled) {
nt36xxx/nt36xxx.c:		disable_irq_wake(ts->client->irq);
nt36xxx/nt36xxx.c:	ts->dev_pm_suspend = false;
nt36xxx/nt36xxx.c:	complete(&ts->dev_pm_suspend_completion);
nt36xxx/nt36xxx.c:	nvt_ts_suspend(ts->client, PMSG_SUSPEND);
nt36xxx/nt36xxx.c:	nvt_ts_resume(ts->client);
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:	data_len = ts->x_num * ts->y_num * 2;
nt36xxx/nt36xxx_ext_proc.c:	mutex_lock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:			CTP_I2C_READ(ts->client, I2C_FW_Address, buf, I2C_TANSFER_LENGTH + 1);
nt36xxx/nt36xxx_ext_proc.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:			CTP_I2C_READ(ts->client, I2C_FW_Address, buf, I2C_TANSFER_LENGTH + 1);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, (TOUCH_KEY_NUM * 2 + 1));
nt36xxx/nt36xxx_ext_proc.c:		xdata[ts->x_num * ts->y_num + i] = (int16_t)(buf[1 + i * 2] + 256 * buf[1 + i * 2 + 1]);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	mutex_lock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:	memcpy(xdata_i, xdata, ((ts->x_num * ts->y_num + TOUCH_KEY_NUM) * sizeof(int32_t)));
nt36xxx/nt36xxx_ext_proc.c:	memcpy(xdata_q, xdata, ((ts->x_num * ts->y_num + TOUCH_KEY_NUM) * sizeof(int32_t)));
nt36xxx/nt36xxx_ext_proc.c:	for (i = 0; i < (ts->x_num * ts->y_num + TOUCH_KEY_NUM); i++) {
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:    *m_x_num = ts->x_num;
nt36xxx/nt36xxx_ext_proc.c:    *m_y_num = ts->y_num;
nt36xxx/nt36xxx_ext_proc.c:	mutex_lock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:	memcpy(buf, xdata, ((ts->x_num * ts->y_num + TOUCH_KEY_NUM) * sizeof(int32_t)));
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->mdata_lock);
nt36xxx/nt36xxx_ext_proc.c:	seq_printf(m, "fw_ver=%d, x_num=%d, y_num=%d, button_num=%d\n", ts->fw_ver, ts->x_num, ts->y_num, ts->max_button_num);
nt36xxx/nt36xxx_ext_proc.c:	for (i = 0; i < ts->y_num; i++) {
nt36xxx/nt36xxx_ext_proc.c:		for (j = 0; j < ts->x_num; j++) {
nt36xxx/nt36xxx_ext_proc.c:			seq_printf(m, "%5d, ", xdata[i * ts->x_num + j]);
nt36xxx/nt36xxx_ext_proc.c:		seq_printf(m, "%5d, ", xdata[ts->x_num * ts->y_num + i]);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_ext_proc.c:		nvt_read_mdata_rss(ts->mmap->BASELINE_ADDR, ts->mmap->BASELINE_Q_ADDR,
nt36xxx/nt36xxx_ext_proc.c:				ts->mmap->BASELINE_BTN_ADDR, ts->mmap->BASELINE_BTN_Q_ADDR);
nt36xxx/nt36xxx_ext_proc.c:		nvt_read_mdata(ts->mmap->BASELINE_ADDR, ts->mmap->BASELINE_BTN_ADDR);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata_rss(ts->mmap->RAW_PIPE0_ADDR, ts->mmap->RAW_PIPE0_Q_ADDR,
nt36xxx/nt36xxx_ext_proc.c:				ts->mmap->RAW_BTN_PIPE0_ADDR, ts->mmap->RAW_BTN_PIPE0_Q_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata_rss(ts->mmap->RAW_PIPE1_ADDR, ts->mmap->RAW_PIPE1_Q_ADDR,
nt36xxx/nt36xxx_ext_proc.c:				ts->mmap->RAW_BTN_PIPE1_ADDR, ts->mmap->RAW_BTN_PIPE1_Q_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata(ts->mmap->RAW_PIPE0_ADDR, ts->mmap->RAW_BTN_PIPE0_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata(ts->mmap->RAW_PIPE1_ADDR, ts->mmap->RAW_BTN_PIPE1_ADDR);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata_rss(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_PIPE0_Q_ADDR,
nt36xxx/nt36xxx_ext_proc.c:				ts->mmap->DIFF_BTN_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_Q_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata_rss(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_PIPE1_Q_ADDR,
nt36xxx/nt36xxx_ext_proc.c:				ts->mmap->DIFF_BTN_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_Q_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_ADDR);
nt36xxx/nt36xxx_ext_proc.c:			nvt_read_mdata(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_ADDR);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 9);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:		CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 7);
nt36xxx/nt36xxx_ext_proc.c:		CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:			cur_sram_addr = ts->mmap->READ_FLASH_CHECKSUM_ADDR + j * 32;
nt36xxx/nt36xxx_ext_proc.c:			CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:			CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 33);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	ret = CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	ret = CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_ext_proc.c:	ret = CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_ext_proc.c:	ret = CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_ext_proc.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_ext_proc.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_fw_update.c:	ret = request_firmware(&fw_entry, filename, &ts->client->dev);
nt36xxx/nt36xxx_fw_update.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_fw_update.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:	uint32_t XDATA_Addr = ts->mmap->READ_FLASH_CHECKSUM_ADDR;
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 7);
nt36xxx/nt36xxx_fw_update.c:				ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 5);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	uint32_t XDATA_Addr = ts->mmap->RW_FLASH_DATA_ADDR;
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 33);
nt36xxx/nt36xxx_fw_update.c:		ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 8);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	uint32_t XDATA_Addr = ts->mmap->READ_FLASH_CHECKSUM_ADDR;
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 7);
nt36xxx/nt36xxx_fw_update.c:				ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:			ret = CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_HW_Address, buf, 7);
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_READ(ts->client, I2C_HW_Address, buf, 2);
nt36xxx/nt36xxx_fw_update.c:	buf[1] = (ts->mmap->READ_FLASH_CHECKSUM_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_fw_update.c:	buf[2] = (ts->mmap->READ_FLASH_CHECKSUM_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_WRITE(ts->client, I2C_BLDR_Address, buf, 3);
nt36xxx/nt36xxx_fw_update.c:	buf[0] = ts->mmap->READ_FLASH_CHECKSUM_ADDR & 0xFF;
nt36xxx/nt36xxx_fw_update.c:	ret = CTP_I2C_READ(ts->client, I2C_BLDR_Address, buf, 6);
nt36xxx/nt36xxx_fw_update.c:	if (ts->fw_name)
nt36xxx/nt36xxx_fw_update.c:		sprintf(firmware_name, ts->fw_name);
nt36xxx/nt36xxx_fw_update.c:	mutex_lock(&ts->lock);
nt36xxx/nt36xxx_fw_update.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 6);
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, 2);
nt36xxx/nt36xxx_mp_ctrlram.c:	nvt_read_mdata(ts->mmap->BASELINE_ADDR, ts->mmap->BASELINE_BTN_ADDR);
nt36xxx/nt36xxx_mp_ctrlram.c:			if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		nvt_read_mdata(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_ADDR);
nt36xxx/nt36xxx_mp_ctrlram.c:		nvt_read_mdata(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_ADDR);
nt36xxx/nt36xxx_mp_ctrlram.c:			if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 5);
nt36xxx/nt36xxx_mp_ctrlram.c:		nvt_read_mdata(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_ADDR);
nt36xxx/nt36xxx_mp_ctrlram.c:		nvt_read_mdata(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_ADDR);
nt36xxx/nt36xxx_mp_ctrlram.c:			if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (!ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 5);
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[1] = (ts->mmap->EVENT_BUF_ADDR >> 16) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	buf[2] = (ts->mmap->EVENT_BUF_ADDR >> 8) & 0xFF;
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 5);
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_pipe_addr = ts->mmap->RAW_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_pipe_addr = ts->mmap->RAW_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, IC_X_CFG_SIZE * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, IC_KEY_CFG_SIZE * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_pipe_addr = ts->mmap->RAW_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:			raw_pipe_addr = ts->mmap->RAW_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:			raw_pipe_addr = ts->mmap->RAW_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, X_Channel * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:			raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE0_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:			raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:	CTP_I2C_READ(ts->client, I2C_FW_Address, buf, Key_Channel * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_pipe_addr = ts->mmap->RAW_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:			CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:			CTP_I2C_READ(ts->client, I2C_FW_Address, buf, X_Channel * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:		raw_btn_pipe_addr = ts->mmap->RAW_BTN_PIPE1_ADDR;
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_WRITE(ts->client, I2C_FW_Address, buf, 3);
nt36xxx/nt36xxx_mp_ctrlram.c:		CTP_I2C_READ(ts->client, I2C_FW_Address, buf, Key_Channel * 2 + 1);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system)
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	nvt_mp_seq_printf(m, "FW Version: %d\n", ts->fw_ver);
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:			if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	retval = request_firmware(&fw_entry, filename, &ts->client->dev);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	struct device_node *np = ts->client->dev.of_node;
nt36xxx/nt36xxx_mp_ctrlram.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	NVT_LOG("ts->nvt_pid: %x\n", ts->nvt_pid);
nt36xxx/nt36xxx_mp_ctrlram.c:	snprintf(mp_setting_criteria_csv_filename, PAGE_SIZE, "NT36xxx_MP_Setting_Criteria_%04X.csv", ts->nvt_pid);
nt36xxx/nt36xxx_mp_ctrlram.c:		snprintf(mpcriteria, PAGE_SIZE, "novatek-mp-criteria-%04X", ts->nvt_pid);
nt36xxx/nt36xxx_mp_ctrlram.c:			mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:		if (ts->carrier_system) {
nt36xxx/nt36xxx_mp_ctrlram.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	if (mutex_lock_interruptible(&ts->lock)) {
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:		mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	mutex_unlock(&ts->lock);
nt36xxx/nt36xxx_mp_ctrlram.c:	cnt = snprintf(tmp, sizeof(ts->result_type), "%d\n", ts->result_type);
nt36xxx/nt36xxx_mp_ctrlram.c:		ts->result_type = NVT_RESULT_INVALID;
nt36xxx/nt36xxx_mp_ctrlram.c:		ts->result_type = NVT_RESULT_PASS;
nt36xxx/nt36xxx_mp_ctrlram.c:		ts->result_type = NVT_RESULT_FAIL;
nt36xxx/nt36xxx_mp_ctrlram.c:	ts->tp_selftest_proc = proc_create("tp_selftest", 0644, NULL, &nvt_selftest_ops);
pcap_ts.c:	switch (pcap_ts->read_state) {
pcap_ts.c:			pcap_ts->pressure = res[0];
pcap_ts.c:		pcap_ts->read_state = PCAP_ADC_TS_M_XY;
pcap_ts.c:		schedule_delayed_work(&pcap_ts->work, 0);
pcap_ts.c:		pcap_ts->y = res[0];
pcap_ts.c:		pcap_ts->x = res[1];
pcap_ts.c:		if (pcap_ts->x <= X_AXIS_MIN || pcap_ts->x >= X_AXIS_MAX ||
pcap_ts.c:		    pcap_ts->y <= Y_AXIS_MIN || pcap_ts->y >= Y_AXIS_MAX) {
pcap_ts.c:			input_report_abs(pcap_ts->input, ABS_PRESSURE, 0);
pcap_ts.c:			input_report_key(pcap_ts->input, BTN_TOUCH, 0);
pcap_ts.c:			pcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;
pcap_ts.c:			schedule_delayed_work(&pcap_ts->work, 0);
pcap_ts.c:			input_report_abs(pcap_ts->input, ABS_X, pcap_ts->x);
pcap_ts.c:			input_report_abs(pcap_ts->input, ABS_Y, pcap_ts->y);
pcap_ts.c:			input_report_key(pcap_ts->input, BTN_TOUCH, 1);
pcap_ts.c:			input_report_abs(pcap_ts->input, ABS_PRESSURE,
pcap_ts.c:						pcap_ts->pressure);
pcap_ts.c:			pcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;
pcap_ts.c:			schedule_delayed_work(&pcap_ts->work,
pcap_ts.c:		input_sync(pcap_ts->input);
pcap_ts.c:		dev_warn(&pcap_ts->input->dev,
pcap_ts.c:				pcap_ts->read_state);
pcap_ts.c:	pcap_set_ts_bits(pcap_ts->pcap,
pcap_ts.c:			pcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);
pcap_ts.c:	if (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY)
pcap_ts.c:	pcap_adc_async(pcap_ts->pcap, PCAP_ADC_BANK_1, 0, ch,
pcap_ts.c:	if (pcap_ts->read_state == PCAP_ADC_TS_M_STANDBY) {
pcap_ts.c:		pcap_ts->read_state = PCAP_ADC_TS_M_PRESSURE;
pcap_ts.c:		schedule_delayed_work(&pcap_ts->work, 0);
pcap_ts.c:	pcap_ts->read_state = PCAP_ADC_TS_M_STANDBY;
pcap_ts.c:	schedule_delayed_work(&pcap_ts->work, 0);
pcap_ts.c:	cancel_delayed_work_sync(&pcap_ts->work);
pcap_ts.c:	pcap_ts->read_state = PCAP_ADC_TS_M_NONTS;
pcap_ts.c:	pcap_set_ts_bits(pcap_ts->pcap,
pcap_ts.c:				pcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);
pcap_ts.c:	pcap_ts->pcap = dev_get_drvdata(pdev->dev.parent);
pcap_ts.c:	INIT_DELAYED_WORK(&pcap_ts->work, pcap_ts_work);
pcap_ts.c:	pcap_ts->read_state = PCAP_ADC_TS_M_NONTS;
pcap_ts.c:	pcap_set_ts_bits(pcap_ts->pcap,
pcap_ts.c:				pcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);
pcap_ts.c:	pcap_ts->input = input_dev;
pcap_ts.c:	err = input_register_device(pcap_ts->input);
pcap_ts.c:	err = request_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS),
pcap_ts.c:	free_irq(pcap_to_irq(pcap_ts->pcap, PCAP_IRQ_TS), pcap_ts);
pcap_ts.c:	cancel_delayed_work_sync(&pcap_ts->work);
pcap_ts.c:	input_unregister_device(pcap_ts->input);
pcap_ts.c:	pcap_set_ts_bits(pcap_ts->pcap, PCAP_ADC_TS_REF_LOWPWR);
pcap_ts.c:	pcap_set_ts_bits(pcap_ts->pcap,
pcap_ts.c:				pcap_ts->read_state << PCAP_ADC_TS_M_SHIFT);
pixcir_i2c_ts.c:	struct device *dev = &ts->client->dev;
pixcir_i2c_ts.c:	const struct pixcir_i2c_chip_data *chip = ts->chip;
pixcir_i2c_ts.c:	if (!ts->chip->has_hw_ids)
pixcir_i2c_ts.c:		input_mt_assign_slots(ts->input, slots, report->pos, n, 0);
pixcir_i2c_ts.c:			slot = input_mt_get_slot_by_key(ts->input,
pixcir_i2c_ts.c:		input_mt_slot(ts->input, slot);
pixcir_i2c_ts.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
pixcir_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_POSITION_X,
pixcir_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_POSITION_Y,
pixcir_i2c_ts.c:	input_mt_sync_frame(ts->input);
pixcir_i2c_ts.c:	input_sync(ts->input);
pixcir_i2c_ts.c:	struct device *dev = &ts->client->dev;
pixcir_i2c_ts.c:		if (ts->gpio_wake)
pixcir_i2c_ts.c:			gpiod_set_value_cansleep(ts->gpio_wake, 1);
pixcir_i2c_ts.c:	ret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_POWER_MODE);
pixcir_i2c_ts.c:	ret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_POWER_MODE, ret);
pixcir_i2c_ts.c:		if (ts->gpio_wake)
pixcir_i2c_ts.c:			gpiod_set_value_cansleep(ts->gpio_wake, 0);
pixcir_i2c_ts.c:	struct device *dev = &ts->client->dev;
pixcir_i2c_ts.c:	ret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);
pixcir_i2c_ts.c:	ret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);
pixcir_i2c_ts.c:	struct device *dev = &ts->client->dev;
pixcir_i2c_ts.c:	ret = i2c_smbus_read_byte_data(ts->client, PIXCIR_REG_INT_MODE);
pixcir_i2c_ts.c:	ret = i2c_smbus_write_byte_data(ts->client, PIXCIR_REG_INT_MODE, ret);
pixcir_i2c_ts.c:	struct device *dev = &ts->client->dev;
pixcir_i2c_ts.c:	if (ts->gpio_enable) {
pixcir_i2c_ts.c:		gpiod_set_value_cansleep(ts->gpio_enable, 1);
pixcir_i2c_ts.c:	ts->running = true;
pixcir_i2c_ts.c:		dev_err(&ts->client->dev,
pixcir_i2c_ts.c:	ts->running = false;
pixcir_i2c_ts.c:	synchronize_irq(ts->client->irq);
pixcir_i2c_ts.c:	if (ts->gpio_enable)
pixcir_i2c_ts.c:		gpiod_set_value_cansleep(ts->gpio_enable, 0);
pixcir_i2c_ts.c:	struct input_dev *input = ts->input;
pixcir_i2c_ts.c:	struct input_dev *input = ts->input;
raspberrypi-ts.c:	memcpy_fromio(&regs, ts->fw_regs_va, sizeof(regs));
raspberrypi-ts.c:		 ts->fw_regs_va + offsetof(struct rpi_ts_regs, num_points));
raspberrypi-ts.c:	    (regs.num_points == 0 && ts->known_ids == 0))
raspberrypi-ts.c:			touchscreen_report_pos(input, &ts->prop, x, y, true);
raspberrypi-ts.c:	released_ids = ts->known_ids & ~modified_ids;
raspberrypi-ts.c:	ts->known_ids = modified_ids;
raspberrypi-ts.c:	struct device *dev = &ts->pdev->dev;
raspberrypi-ts.c:	dma_free_coherent(dev, PAGE_SIZE, ts->fw_regs_va, ts->fw_regs_phys);
raspberrypi-ts.c:	ts->pdev = pdev;
raspberrypi-ts.c:	ts->fw_regs_va = dma_alloc_coherent(dev, PAGE_SIZE, &ts->fw_regs_phys,
raspberrypi-ts.c:	if (!ts->fw_regs_va) {
raspberrypi-ts.c:	touchbuf = (u32)ts->fw_regs_phys;
raspberrypi-ts.c:	ts->input = input;
raspberrypi-ts.c:	touchscreen_parse_properties(input, true, &ts->prop);
raydium_i2c_ts.c:	struct i2c_client *client = ts->client;
raydium_i2c_ts.c:		if (ts->report_data && ts->pkg_size != data_info.pkg_size) {
raydium_i2c_ts.c:				 ts->pkg_size, data_info.pkg_size);
raydium_i2c_ts.c:			ts->pkg_size = data_info.pkg_size;
raydium_i2c_ts.c:			ts->report_size = ts->pkg_size - RM_PACKET_CRC_SIZE;
raydium_i2c_ts.c:		ts->contact_size = data_info.tp_info_size;
raydium_i2c_ts.c:		ts->data_bank_addr = le32_to_cpu(data_info.data_bank_addr);
raydium_i2c_ts.c:			ts->data_bank_addr, ts->report_size, ts->contact_size);
raydium_i2c_ts.c:						 &ts->info, sizeof(ts->info));
raydium_i2c_ts.c:	struct i2c_client *client = ts->client;
raydium_i2c_ts.c:			ts->boot_mode = RAYDIUM_TS_BLDR;
raydium_i2c_ts.c:			ts->boot_mode = RAYDIUM_TS_MAIN;
raydium_i2c_ts.c:	struct i2c_client *client = ts->client;
raydium_i2c_ts.c:		if (ts->boot_mode == RAYDIUM_TS_BLDR ||
raydium_i2c_ts.c:		    ts->boot_mode == RAYDIUM_TS_MAIN) {
raydium_i2c_ts.c:		ts->boot_mode = RAYDIUM_TS_BLDR;
raydium_i2c_ts.c:	if (ts->boot_mode == RAYDIUM_TS_BLDR) {
raydium_i2c_ts.c:		ts->info.hw_ver = cpu_to_le32(0xffffffffUL);
raydium_i2c_ts.c:		ts->info.main_ver = 0xff;
raydium_i2c_ts.c:		ts->info.sub_ver = 0xff;
raydium_i2c_ts.c:	struct i2c_client *client = ts->client;
raydium_i2c_ts.c:	if (ts->boot_mode == RAYDIUM_TS_MAIN) {
raydium_i2c_ts.c:				if (ts->boot_mode == RAYDIUM_TS_BLDR)
raydium_i2c_ts.c:		if (ts->boot_mode == RAYDIUM_TS_MAIN) {
raydium_i2c_ts.c:	if (ts->boot_mode != RAYDIUM_TS_MAIN) {
raydium_i2c_ts.c:	struct i2c_client *client = ts->client;
raydium_i2c_ts.c:		ts->boot_mode = RAYDIUM_TS_BLDR;
raydium_i2c_ts.c:		ts->boot_mode = RAYDIUM_TS_BLDR;
raydium_i2c_ts.c:	ts->boot_mode = RAYDIUM_TS_MAIN;
raydium_i2c_ts.c:	for (i = 0; i < ts->report_size / ts->contact_size; i++) {
raydium_i2c_ts.c:		u8 *contact = &ts->report_data[ts->contact_size * i];
raydium_i2c_ts.c:		input_mt_slot(ts->input, i);
raydium_i2c_ts.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, state);
raydium_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_POSITION_X,
raydium_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_POSITION_Y,
raydium_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_PRESSURE,
raydium_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR, max(wx, wy));
raydium_i2c_ts.c:		input_report_abs(ts->input, ABS_MT_TOUCH_MINOR, min(wx, wy));
raydium_i2c_ts.c:	input_mt_sync_frame(ts->input);
raydium_i2c_ts.c:	input_sync(ts->input);
raydium_i2c_ts.c:	if (ts->boot_mode != RAYDIUM_TS_MAIN)
raydium_i2c_ts.c:	error = raydium_i2c_read_message(ts->client, ts->data_bank_addr,
raydium_i2c_ts.c:					 ts->report_data, ts->pkg_size);
raydium_i2c_ts.c:	fw_crc = get_unaligned_le16(&ts->report_data[ts->report_size]);
raydium_i2c_ts.c:	calc_crc = raydium_calc_chksum(ts->report_data, ts->report_size);
raydium_i2c_ts.c:		dev_warn(&ts->client->dev,
raydium_i2c_ts.c:	return sprintf(buf, "%d.%d\n", ts->info.main_ver, ts->info.sub_ver);
raydium_i2c_ts.c:	return sprintf(buf, "%#04x\n", le32_to_cpu(ts->info.hw_ver));
raydium_i2c_ts.c:		       ts->boot_mode == RAYDIUM_TS_MAIN ?
raydium_i2c_ts.c:	error = mutex_lock_interruptible(&ts->sysfs_mutex);
raydium_i2c_ts.c:	mutex_unlock(&ts->sysfs_mutex);
raydium_i2c_ts.c:	error = mutex_lock_interruptible(&ts->sysfs_mutex);
raydium_i2c_ts.c:	mutex_unlock(&ts->sysfs_mutex);
raydium_i2c_ts.c:	sysfs_remove_group(&ts->client->dev.kobj, &raydium_i2c_attribute_group);
raydium_i2c_ts.c:	if (!ts->reset_gpio)
raydium_i2c_ts.c:	gpiod_set_value_cansleep(ts->reset_gpio, 1);
raydium_i2c_ts.c:	error = regulator_enable(ts->avdd);
raydium_i2c_ts.c:		dev_err(&ts->client->dev,
raydium_i2c_ts.c:	error = regulator_enable(ts->vccio);
raydium_i2c_ts.c:		regulator_disable(ts->avdd);
raydium_i2c_ts.c:		dev_err(&ts->client->dev,
raydium_i2c_ts.c:	gpiod_set_value_cansleep(ts->reset_gpio, 0);
raydium_i2c_ts.c:	if (ts->reset_gpio) {
raydium_i2c_ts.c:		gpiod_set_value_cansleep(ts->reset_gpio, 1);
raydium_i2c_ts.c:		regulator_disable(ts->vccio);
raydium_i2c_ts.c:		regulator_disable(ts->avdd);
raydium_i2c_ts.c:	mutex_init(&ts->sysfs_mutex);
raydium_i2c_ts.c:	ts->client = client;
raydium_i2c_ts.c:	ts->avdd = devm_regulator_get(&client->dev, "avdd");
raydium_i2c_ts.c:	if (IS_ERR(ts->avdd)) {
raydium_i2c_ts.c:		error = PTR_ERR(ts->avdd);
raydium_i2c_ts.c:	ts->vccio = devm_regulator_get(&client->dev, "vccio");
raydium_i2c_ts.c:	if (IS_ERR(ts->vccio)) {
raydium_i2c_ts.c:		error = PTR_ERR(ts->vccio);
raydium_i2c_ts.c:	ts->reset_gpio = devm_gpiod_get_optional(&client->dev, "reset",
raydium_i2c_ts.c:	if (IS_ERR(ts->reset_gpio)) {
raydium_i2c_ts.c:		error = PTR_ERR(ts->reset_gpio);
raydium_i2c_ts.c:	ts->report_data = devm_kmalloc(&client->dev,
raydium_i2c_ts.c:				       ts->pkg_size, GFP_KERNEL);
raydium_i2c_ts.c:	if (!ts->report_data)
raydium_i2c_ts.c:	ts->input = devm_input_allocate_device(&client->dev);
raydium_i2c_ts.c:	if (!ts->input) {
raydium_i2c_ts.c:	ts->input->name = "Raydium Touchscreen";
raydium_i2c_ts.c:	ts->input->id.bustype = BUS_I2C;
raydium_i2c_ts.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_X,
raydium_i2c_ts.c:			     0, le16_to_cpu(ts->info.x_max), 0, 0);
raydium_i2c_ts.c:	input_set_abs_params(ts->input, ABS_MT_POSITION_Y,
raydium_i2c_ts.c:			     0, le16_to_cpu(ts->info.y_max), 0, 0);
raydium_i2c_ts.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_X, ts->info.x_res);
raydium_i2c_ts.c:	input_abs_set_res(ts->input, ABS_MT_POSITION_Y, ts->info.y_res);
raydium_i2c_ts.c:	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
raydium_i2c_ts.c:	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
raydium_i2c_ts.c:	error = input_mt_init_slots(ts->input, RM_MAX_TOUCH_NUM,
raydium_i2c_ts.c:	error = input_register_device(ts->input);
raydium_i2c_ts.c:	if (ts->boot_mode != RAYDIUM_TS_MAIN)
raydium_i2c_ts.c:		ts->wake_irq_enabled = (enable_irq_wake(client->irq) == 0);
raydium_i2c_ts.c:		if (ts->wake_irq_enabled)
rohm_bu21023.c:	struct i2c_client *client = ts->client;
rohm_bu21023.c:	struct i2c_client *client = ts->client;
rohm_bu21023.c:	struct input_dev *input_dev = ts->input;
rohm_bu21023.c:	int prev_finger_count = ts->finger_count;
rohm_bu21023.c:		if (++ts->contact_count[0] >= threshold)
rohm_bu21023.c:		if (++ts->contact_count[1] >= threshold)
rohm_bu21023.c:		if (++ts->contact_count[2] >= threshold)
rohm_bu21023.c:			count = ts->contact_count[finger_count];
rohm_bu21023.c:			memset(ts->contact_count, 0, sizeof(ts->contact_count));
rohm_bu21023.c:			ts->contact_count[finger_count] = count;
rohm_bu21023.c:		ts->finger_count = finger_count;
rohm_bu21023.c:	return sprintf(buf, "%d\n", !!(ts->setup2 & SWAP_XY));
rohm_bu21023.c:	error = mutex_lock_interruptible(&ts->input->mutex);
rohm_bu21023.c:		ts->setup2 |= SWAP_XY;
rohm_bu21023.c:		ts->setup2 &= ~SWAP_XY;
rohm_bu21023.c:	if (ts->initialized)
rohm_bu21023.c:		error = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,
rohm_bu21023.c:						  ts->setup2);
rohm_bu21023.c:	mutex_unlock(&ts->input->mutex);
rohm_bu21023.c:	return sprintf(buf, "%d\n", !!(ts->setup2 & INV_X));
rohm_bu21023.c:	error = mutex_lock_interruptible(&ts->input->mutex);
rohm_bu21023.c:		ts->setup2 |= INV_X;
rohm_bu21023.c:		ts->setup2 &= ~INV_X;
rohm_bu21023.c:	if (ts->initialized)
rohm_bu21023.c:		error = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,
rohm_bu21023.c:						  ts->setup2);
rohm_bu21023.c:	mutex_unlock(&ts->input->mutex);
rohm_bu21023.c:	return sprintf(buf, "%d\n", !!(ts->setup2 & INV_Y));
rohm_bu21023.c:	error = mutex_lock_interruptible(&ts->input->mutex);
rohm_bu21023.c:		ts->setup2 |= INV_Y;
rohm_bu21023.c:		ts->setup2 &= ~INV_Y;
rohm_bu21023.c:	if (ts->initialized)
rohm_bu21023.c:						  ts->setup2);
rohm_bu21023.c:	mutex_unlock(&ts->input->mutex);
rohm_bu21023.c:	struct i2c_client *client = ts->client;
rohm_bu21023.c:	if (!ts->initialized) {
rohm_bu21023.c:		error = rohm_ts_device_init(client, ts->setup2);
rohm_bu21023.c:		ts->initialized = true;
rohm_bu21023.c:	rohm_ts_power_off(ts->client);
rohm_bu21023.c:	ts->initialized = false;
rohm_bu21023.c:	ts->client = client;
rohm_bu21023.c:	ts->setup2 = MAF_1SAMPLE;
rohm_bu21023.c:	ts->input = input;
sis_i2c.c:	struct input_dev *input = ts->input;
sis_i2c.c:		dev_err(&ts->client->dev, "Unexpected touch status: %#02x\n",
sis_i2c.c:		error = sis_read_packet(ts->client, ts->packet,
sis_i2c.c:			dev_err(&ts->client->dev,
sis_i2c.c:		report_id = ts->packet[SIS_PKT_REPORT_OFFSET];
sis_i2c.c:		contact = &ts->packet[SIS_PKT_CONTACT_OFFSET];
sis_i2c.c:	input_mt_sync_frame(ts->input);
sis_i2c.c:	input_sync(ts->input);
sis_i2c.c:	} while (ts->attn_gpio && gpiod_get_value_cansleep(ts->attn_gpio));
sis_i2c.c:	if (ts->reset_gpio) {
sis_i2c.c:		gpiod_set_value(ts->reset_gpio, 1);
sis_i2c.c:		gpiod_set_value(ts->reset_gpio, 0);
sis_i2c.c:	ts->client = client;
sis_i2c.c:	ts->attn_gpio = devm_gpiod_get_optional(&client->dev,
sis_i2c.c:	if (IS_ERR(ts->attn_gpio)) {
sis_i2c.c:		error = PTR_ERR(ts->attn_gpio);
sis_i2c.c:	ts->reset_gpio = devm_gpiod_get_optional(&client->dev,
sis_i2c.c:	if (IS_ERR(ts->reset_gpio)) {
sis_i2c.c:		error = PTR_ERR(ts->reset_gpio);
sis_i2c.c:	ts->input = input = devm_input_allocate_device(&client->dev);
sis_i2c.c:	error = input_register_device(ts->input);
st/fts.c:	info->fwu_workqueue = alloc_workqueue("fts-fwu-queue",
st/fts.c:	info->event_wq = alloc_workqueue("fts-event-queue",
st1232.c:	struct st1232_ts_finger *finger = ts->finger;
st1232.c:	struct i2c_client *client = ts->client;
st1232.c:	msg[1].addr = ts->client->addr;
st1232.c:	struct st1232_ts_finger *finger = ts->finger;
st1232.c:	struct input_dev *input_dev = ts->input_dev;
st1232.c:		if (ts->low_latency_req.dev) {
st1232.c:			dev_pm_qos_remove_request(&ts->low_latency_req);
st1232.c:			ts->low_latency_req.dev = NULL;
st1232.c:	} else if (!ts->low_latency_req.dev) {
st1232.c:		dev_pm_qos_add_ancestor_request(&ts->client->dev,
st1232.c:						&ts->low_latency_req,
st1232.c:	if (gpio_is_valid(ts->reset_gpio))
st1232.c:		gpio_direction_output(ts->reset_gpio, poweron);
st1232.c:	ts->client = client;
st1232.c:	ts->input_dev = input_dev;
st1232.c:		ts->reset_gpio = pdata->reset_gpio;
st1232.c:		ts->reset_gpio = of_get_gpio(client->dev.of_node, 0);
st1232.c:		ts->reset_gpio = -ENODEV;
st1232.c:	if (gpio_is_valid(ts->reset_gpio)) {
st1232.c:		error = devm_gpio_request(&client->dev, ts->reset_gpio, NULL);
st1232.c:				ts->reset_gpio);
st1232.c:	error = input_register_device(ts->input_dev);
stmpe-ts.c:	int_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);
stmpe-ts.c:		int_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);
stmpe-ts.c:	__stmpe_reset_fifo(ts->stmpe);
stmpe-ts.c:	input_report_abs(ts->idev, ABS_PRESSURE, 0);
stmpe-ts.c:	input_report_key(ts->idev, BTN_TOUCH, 0);
stmpe-ts.c:	input_sync(ts->idev);
stmpe-ts.c:	cancel_delayed_work_sync(&ts->work);
stmpe-ts.c:	stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
stmpe-ts.c:	stmpe_block_read(ts->stmpe, STMPE_REG_TSC_DATA_XYZ, 4, data_set);
stmpe-ts.c:	input_report_abs(ts->idev, ABS_X, x);
stmpe-ts.c:	input_report_abs(ts->idev, ABS_Y, y);
stmpe-ts.c:	input_report_abs(ts->idev, ABS_PRESSURE, z);
stmpe-ts.c:	input_report_key(ts->idev, BTN_TOUCH, 1);
stmpe-ts.c:	input_sync(ts->idev);
stmpe-ts.c:	__stmpe_reset_fifo(ts->stmpe);
stmpe-ts.c:	stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
stmpe-ts.c:	schedule_delayed_work(&ts->work, msecs_to_jiffies(50));
stmpe-ts.c:	struct stmpe *stmpe = ts->stmpe;
stmpe-ts.c:	struct device *dev = ts->dev;
stmpe-ts.c:	adc_ctrl1 = SAMPLE_TIME(ts->sample_time) | MOD_12B(ts->mod_12b) |
stmpe-ts.c:		REF_SEL(ts->ref_sel);
stmpe-ts.c:			ADC_FREQ(0xff), ADC_FREQ(ts->adc_freq));
stmpe-ts.c:	tsc_cfg = AVE_CTRL(ts->ave_ctrl) | DET_DELAY(ts->touch_det_delay) |
stmpe-ts.c:			SETTLING(ts->settling);
stmpe-ts.c:			FRACTION_Z(0xff), FRACTION_Z(ts->fraction_z));
stmpe-ts.c:			I_DRIVE(0xff), I_DRIVE(ts->i_drive));
stmpe-ts.c:	ret = __stmpe_reset_fifo(ts->stmpe);
stmpe-ts.c:	return stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
stmpe-ts.c:	cancel_delayed_work_sync(&ts->work);
stmpe-ts.c:	stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
stmpe-ts.c:			ts->sample_time = val;
stmpe-ts.c:			ts->mod_12b = val;
stmpe-ts.c:			ts->ref_sel = val;
stmpe-ts.c:			ts->adc_freq = val;
stmpe-ts.c:			ts->ave_ctrl = val;
stmpe-ts.c:			ts->touch_det_delay = val;
stmpe-ts.c:			ts->settling = val;
stmpe-ts.c:			ts->fraction_z = val;
stmpe-ts.c:			ts->i_drive = val;
stmpe-ts.c:	ts->stmpe = stmpe;
stmpe-ts.c:	ts->idev = idev;
stmpe-ts.c:	ts->dev = &pdev->dev;
stmpe-ts.c:	INIT_DELAYED_WORK(&ts->work, stmpe_work);
stmpe-ts.c:	stmpe_disable(ts->stmpe, STMPE_BLOCK_TOUCHSCREEN);
sun4i-ts.c:		x = readl(ts->base + TP_DATA);
sun4i-ts.c:		y = readl(ts->base + TP_DATA);
sun4i-ts.c:		if (!ts->ignore_fifo_data) {
sun4i-ts.c:			input_report_abs(ts->input, ABS_X, x);
sun4i-ts.c:			input_report_abs(ts->input, ABS_Y, y);
sun4i-ts.c:			input_report_key(ts->input, BTN_TOUCH, 1);
sun4i-ts.c:			input_sync(ts->input);
sun4i-ts.c:			ts->ignore_fifo_data = false;
sun4i-ts.c:		ts->ignore_fifo_data = true;
sun4i-ts.c:		input_report_key(ts->input, BTN_TOUCH, 0);
sun4i-ts.c:		input_sync(ts->input);
sun4i-ts.c:	reg_val  = readl(ts->base + TP_INT_FIFOS);
sun4i-ts.c:		ts->temp_data = readl(ts->base + TEMP_DATA);
sun4i-ts.c:	if (ts->input)
sun4i-ts.c:	writel(reg_val, ts->base + TP_INT_FIFOS);
sun4i-ts.c:		TP_UP_IRQ_EN(1), ts->base + TP_INT_FIFOC);
sun4i-ts.c:	writel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);
sun4i-ts.c:	if (ts->temp_data == -1)
sun4i-ts.c:	*temp = ts->temp_data * ts->temp_step - ts->temp_offset;
sun4i-ts.c:	ts->dev = dev;
sun4i-ts.c:	ts->ignore_fifo_data = true;
sun4i-ts.c:	ts->temp_data = -1;
sun4i-ts.c:		ts->temp_offset = 271000;
sun4i-ts.c:		ts->temp_step = 167;
sun4i-ts.c:		ts->temp_offset = 257000;
sun4i-ts.c:		ts->temp_step = 133;
sun4i-ts.c:		ts->temp_offset = 144700;
sun4i-ts.c:		ts->temp_step = 100;
sun4i-ts.c:	ts_attached = of_property_read_bool(np, "allwinner,ts-attached");
sun4i-ts.c:		ts->input = devm_input_allocate_device(dev);
sun4i-ts.c:		if (!ts->input)
sun4i-ts.c:		ts->input->name = pdev->name;
sun4i-ts.c:		ts->input->phys = "sun4i_ts/input0";
sun4i-ts.c:		ts->input->open = sun4i_ts_open;
sun4i-ts.c:		ts->input->close = sun4i_ts_close;
sun4i-ts.c:		ts->input->id.bustype = BUS_HOST;
sun4i-ts.c:		ts->input->id.vendor = 0x0001;
sun4i-ts.c:		ts->input->id.product = 0x0001;
sun4i-ts.c:		ts->input->id.version = 0x0100;
sun4i-ts.c:		ts->input->evbit[0] =  BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);
sun4i-ts.c:		__set_bit(BTN_TOUCH, ts->input->keybit);
sun4i-ts.c:		input_set_abs_params(ts->input, ABS_X, 0, 4095, 0, 0);
sun4i-ts.c:		input_set_abs_params(ts->input, ABS_Y, 0, 4095, 0, 0);
sun4i-ts.c:		input_set_drvdata(ts->input, ts);
sun4i-ts.c:	ts->base = devm_ioremap_resource(dev,
sun4i-ts.c:	if (IS_ERR(ts->base))
sun4i-ts.c:		return PTR_ERR(ts->base);
sun4i-ts.c:	ts->irq = platform_get_irq(pdev, 0);
sun4i-ts.c:	error = devm_request_irq(dev, ts->irq, sun4i_ts_irq, 0, "sun4i-ts", ts);
sun4i-ts.c:	       ts->base + TP_CTRL0);
sun4i-ts.c:	       ts->base + TP_CTRL2);
sun4i-ts.c:	writel(FILTER_EN(1) | FILTER_TYPE(filter_type), ts->base + TP_CTRL3);
sun4i-ts.c:	writel(TEMP_ENABLE(1) | TEMP_PERIOD(1953), ts->base + TP_TPR);
sun4i-ts.c:	writel(reg, ts->base + TP_CTRL1);
sun4i-ts.c:	hwmon = devm_hwmon_device_register_with_groups(ts->dev, "sun4i_ts",
sun4i-ts.c:	devm_thermal_zone_of_sensor_register(ts->dev, 0, ts, &sun4i_ts_tz_ops);
sun4i-ts.c:	writel(TEMP_IRQ_EN(1), ts->base + TP_INT_FIFOC);
sun4i-ts.c:		error = input_register_device(ts->input);
sun4i-ts.c:			writel(0, ts->base + TP_INT_FIFOC);
sun4i-ts.c:	if (ts->input)
sun4i-ts.c:		input_unregister_device(ts->input);
sun4i-ts.c:	writel(0, ts->base + TP_INT_FIFOC);
ti_am335x_tsc.c:	return readl(ts->mfd_tscadc->tscadc_base + reg);
ts4800-ts.c:	ts->pendown = false;
ts4800-ts.c:	ts->debounce = DEBOUNCE_COUNT;
ts4800-ts.c:	ret = regmap_update_bits(ts->regmap, ts->reg, ts->bit, ts->bit);
ts4800-ts.c:		dev_warn(ts->dev, "Failed to enable touchscreen\n");
ts4800-ts.c:	ret = regmap_update_bits(ts->regmap, ts->reg, ts->bit, 0);
ts4800-ts.c:		dev_warn(ts->dev, "Failed to disable touchscreen\n");
ts4800-ts.c:	u16 last_x = readw(ts->base + X_OFFSET);
ts4800-ts.c:	u16 last_y = readw(ts->base + Y_OFFSET);
ts4800-ts.c:		if (ts->debounce) {
ts4800-ts.c:			ts->debounce--;
ts4800-ts.c:		if (!ts->pendown) {
ts4800-ts.c:			ts->pendown = true;
ts4800-ts.c:	} else if (ts->pendown) {
ts4800-ts.c:		ts->pendown = false;
ts4800-ts.c:		ts->debounce = DEBOUNCE_COUNT;
ts4800-ts.c:	ts->regmap = syscon_node_to_regmap(syscon_np);
ts4800-ts.c:	if (IS_ERR(ts->regmap)) {
ts4800-ts.c:		return PTR_ERR(ts->regmap);
ts4800-ts.c:	ts->reg = reg;
ts4800-ts.c:	ts->bit = BIT(bit);
ts4800-ts.c:	ts->base = devm_ioremap_resource(&pdev->dev, res);
ts4800-ts.c:	if (IS_ERR(ts->base))
ts4800-ts.c:		return PTR_ERR(ts->base);
ts4800-ts.c:	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&pdev->dev));
ts4800-ts.c:	ts->poll_dev = poll_dev;
ts4800-ts.c:	ts->dev = &pdev->dev;
ts4800-ts.c:	poll_dev->input->phys = ts->phys;
tsc2007_core.c:	if (!ts->get_pendown_state)
tsc2007_core.c:	return ts->get_pendown_state(&ts->client->dev);
tsc2007_core.c:	struct input_dev *input = ts->input;
tsc2007_core.c:	while (!ts->stopped && tsc2007_is_pen_down(ts)) {
tsc2007_core.c:		mutex_lock(&ts->mlock);
tsc2007_core.c:		mutex_unlock(&ts->mlock);
tsc2007_core.c:		if (!rt && !ts->get_pendown_state) {
tsc2007_core.c:		if (rt <= ts->max_rt) {
tsc2007_core.c:			dev_dbg(&ts->client->dev,
tsc2007_core.c:			rt = ts->max_rt - rt;
tsc2007_core.c:			dev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);
tsc2007_core.c:		wait_event_timeout(ts->wait, ts->stopped, ts->poll_period);
tsc2007_core.c:	dev_dbg(&ts->client->dev, "UP\n");
tsc2007_core.c:	if (ts->clear_penirq)
tsc2007_core.c:		ts->clear_penirq();
tsc2007_core.c:	if (ts->clear_penirq)
tsc2007_core.c:		ts->clear_penirq();
tsc2007_core.c:	ts->stopped = true;
tsc2007_core.c:	wake_up(&ts->wait);
tsc2007_core.c:	disable_irq(ts->irq);
tsc2007_core.c:	ts->stopped = false;
tsc2007_core.c:	enable_irq(ts->irq);
tsc2007_core.c:	return !gpio_get_value(ts->gpio);
tsc2007_core.c:		ts->max_rt = val32;
tsc2007_core.c:		ts->max_rt = MAX_12BIT;
tsc2007_core.c:		ts->fuzzx = val32;
tsc2007_core.c:		ts->fuzzy = val32;
tsc2007_core.c:		ts->fuzzz = val32;
tsc2007_core.c:		ts->poll_period = msecs_to_jiffies(val64);
tsc2007_core.c:		ts->poll_period = msecs_to_jiffies(1);
tsc2007_core.c:		ts->x_plate_ohms = val32;
tsc2007_core.c:	ts->gpio = of_get_gpio(np, 0);
tsc2007_core.c:	if (gpio_is_valid(ts->gpio))
tsc2007_core.c:		ts->get_pendown_state = tsc2007_get_pendown_state_gpio;
tsc2007_core.c:			 ts->gpio);
tsc2007_core.c:	ts->model             = pdata->model;
tsc2007_core.c:	ts->x_plate_ohms      = pdata->x_plate_ohms;
tsc2007_core.c:	ts->max_rt            = pdata->max_rt ? : MAX_12BIT;
tsc2007_core.c:	ts->poll_period       = msecs_to_jiffies(pdata->poll_period ? : 1);
tsc2007_core.c:	ts->get_pendown_state = pdata->get_pendown_state;
tsc2007_core.c:	ts->clear_penirq      = pdata->clear_penirq;
tsc2007_core.c:	ts->fuzzx             = pdata->fuzzx;
tsc2007_core.c:	ts->fuzzy             = pdata->fuzzy;
tsc2007_core.c:	ts->fuzzz             = pdata->fuzzz;
tsc2007_core.c:	ts->client = client;
tsc2007_core.c:	ts->irq = client->irq;
tsc2007_core.c:	ts->input = input_dev;
tsc2007_core.c:	init_waitqueue_head(&ts->wait);
tsc2007_core.c:	mutex_init(&ts->mlock);
tsc2007_core.c:	snprintf(ts->phys, sizeof(ts->phys),
tsc2007_core.c:	input_dev->phys = ts->phys;
tsc2007_core.c:	input_set_abs_params(input_dev, ABS_X, 0, MAX_12BIT, ts->fuzzx, 0);
tsc2007_core.c:	input_set_abs_params(input_dev, ABS_Y, 0, MAX_12BIT, ts->fuzzy, 0);
tsc2007_core.c:			     ts->fuzzz, 0);
tsc2007_core.c:	err = devm_request_threaded_irq(&client->dev, ts->irq,
tsc2007_core.c:			ts->irq, err);
tsc2007_iio.c:	indio_dev = devm_iio_device_alloc(&ts->client->dev, sizeof(*iio));
tsc2007_iio.c:		dev_err(&ts->client->dev, "iio_device_alloc failed\n");
tsc2007_iio.c:	indio_dev->dev.parent = &ts->client->dev;
tsc2007_iio.c:	error = devm_iio_device_register(&ts->client->dev, indio_dev);
tsc2007_iio.c:		dev_err(&ts->client->dev,
tsc200x-core.c:		input_report_abs(ts->idev, ABS_X, x);
tsc200x-core.c:		input_report_abs(ts->idev, ABS_Y, y);
tsc200x-core.c:		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
tsc200x-core.c:		if (!ts->pen_down) {
tsc200x-core.c:			input_report_key(ts->idev, BTN_TOUCH, !!pressure);
tsc200x-core.c:			ts->pen_down = true;
tsc200x-core.c:		input_report_abs(ts->idev, ABS_PRESSURE, 0);
tsc200x-core.c:		if (ts->pen_down) {
tsc200x-core.c:			input_report_key(ts->idev, BTN_TOUCH, 0);
tsc200x-core.c:			ts->pen_down = false;
tsc200x-core.c:	input_sync(ts->idev);
tsc200x-core.c:	dev_dbg(ts->dev, "point(%4d,%4d), pressure (%4d)\n", x, y,
tsc200x-core.c:	error = regmap_bulk_read(ts->regmap, TSC200X_REG_X, &tsdata,
tsc200x-core.c:	if (!ts->pen_down &&
tsc200x-core.c:	    ts->in_x == tsdata.x && ts->in_y == tsdata.y &&
tsc200x-core.c:	    ts->in_z1 == tsdata.z1 && ts->in_z2 == tsdata.z2) {
tsc200x-core.c:	ts->in_x = tsdata.x;
tsc200x-core.c:	ts->in_y = tsdata.y;
tsc200x-core.c:	ts->in_z1 = tsdata.z1;
tsc200x-core.c:	ts->in_z2 = tsdata.z2;
tsc200x-core.c:	pressure = pressure * ts->x_plate_ohm / 4096;
tsc200x-core.c:	spin_lock_irqsave(&ts->lock, flags);
tsc200x-core.c:	mod_timer(&ts->penup_timer,
tsc200x-core.c:	spin_unlock_irqrestore(&ts->lock, flags);
tsc200x-core.c:	ts->last_valid_interrupt = jiffies;
tsc200x-core.c:	spin_lock_irqsave(&ts->lock, flags);
tsc200x-core.c:	spin_unlock_irqrestore(&ts->lock, flags);
tsc200x-core.c:	regmap_write(ts->regmap, TSC200X_REG_CFR0, TSC200X_CFR0_INITVALUE);
tsc200x-core.c:	regmap_write(ts->regmap, TSC200X_REG_CFR1, TSC200X_CFR1_INITVALUE);
tsc200x-core.c:	regmap_write(ts->regmap, TSC200X_REG_CFR2, TSC200X_CFR2_INITVALUE);
tsc200x-core.c:	ts->tsc200x_cmd(ts->dev, TSC200X_CMD_NORMAL);
tsc200x-core.c:	ts->tsc200x_cmd(ts->dev, TSC200X_CMD_STOP);
tsc200x-core.c:	if (ts->reset_gpio) {
tsc200x-core.c:		gpiod_set_value_cansleep(ts->reset_gpio, 1);
tsc200x-core.c:		gpiod_set_value_cansleep(ts->reset_gpio, 0);
tsc200x-core.c:/* must be called with ts->mutex held */
tsc200x-core.c:	disable_irq(ts->irq);
tsc200x-core.c:	del_timer_sync(&ts->penup_timer);
tsc200x-core.c:	cancel_delayed_work_sync(&ts->esd_work);
tsc200x-core.c:	enable_irq(ts->irq);
tsc200x-core.c:/* must be called with ts->mutex held */
tsc200x-core.c:	if (ts->esd_timeout && ts->reset_gpio) {
tsc200x-core.c:		ts->last_valid_interrupt = jiffies;
tsc200x-core.c:		schedule_delayed_work(&ts->esd_work,
tsc200x-core.c:					msecs_to_jiffies(ts->esd_timeout)));
tsc200x-core.c:	mutex_lock(&ts->mutex);
tsc200x-core.c:	error = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high_orig);
tsc200x-core.c:	error = regmap_write(ts->regmap, TSC200X_REG_TEMP_HIGH, temp_high_test);
tsc200x-core.c:	error = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);
tsc200x-core.c:	error = regmap_read(ts->regmap, TSC200X_REG_TEMP_HIGH, &temp_high);
tsc200x-core.c:	mutex_unlock(&ts->mutex);
tsc200x-core.c:		if (!ts->reset_gpio)
tsc200x-core.c:	if (!mutex_trylock(&ts->mutex)) {
tsc200x-core.c:	if (time_is_after_jiffies(ts->last_valid_interrupt +
tsc200x-core.c:				  msecs_to_jiffies(ts->esd_timeout)))
tsc200x-core.c:	error = regmap_read(ts->regmap, TSC200X_REG_CFR0, &r);
tsc200x-core.c:	dev_info(ts->dev, "TSC200X not responding - resetting\n");
tsc200x-core.c:	disable_irq(ts->irq);
tsc200x-core.c:	del_timer_sync(&ts->penup_timer);
tsc200x-core.c:	enable_irq(ts->irq);
tsc200x-core.c:	mutex_unlock(&ts->mutex);
tsc200x-core.c:	schedule_delayed_work(&ts->esd_work,
tsc200x-core.c:					msecs_to_jiffies(ts->esd_timeout)));
tsc200x-core.c:	mutex_lock(&ts->mutex);
tsc200x-core.c:	if (!ts->suspended)
tsc200x-core.c:	ts->opened = true;
tsc200x-core.c:	mutex_unlock(&ts->mutex);
tsc200x-core.c:	mutex_lock(&ts->mutex);
tsc200x-core.c:	if (!ts->suspended)
tsc200x-core.c:	ts->opened = false;
tsc200x-core.c:	mutex_unlock(&ts->mutex);
tsc200x-core.c:	ts->irq = irq;
tsc200x-core.c:	ts->dev = dev;
tsc200x-core.c:	ts->idev = input_dev;
tsc200x-core.c:	ts->regmap = regmap;
tsc200x-core.c:	ts->tsc200x_cmd = tsc200x_cmd;
tsc200x-core.c:	ts->x_plate_ohm = error ? TSC200X_DEF_RESISTOR : x_plate_ohm;
tsc200x-core.c:	ts->esd_timeout = error ? 0 : esd_timeout;
tsc200x-core.c:	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
tsc200x-core.c:	if (IS_ERR(ts->reset_gpio)) {
tsc200x-core.c:		error = PTR_ERR(ts->reset_gpio);
tsc200x-core.c:	ts->vio = devm_regulator_get(dev, "vio");
tsc200x-core.c:	if (IS_ERR(ts->vio)) {
tsc200x-core.c:		error = PTR_ERR(ts->vio);
tsc200x-core.c:	mutex_init(&ts->mutex);
tsc200x-core.c:	spin_lock_init(&ts->lock);
tsc200x-core.c:	setup_timer(&ts->penup_timer, tsc200x_penup_timer, (unsigned long)ts);
tsc200x-core.c:	INIT_DELAYED_WORK(&ts->esd_work, tsc200x_esd_work);
tsc200x-core.c:	snprintf(ts->phys, sizeof(ts->phys),
tsc200x-core.c:	input_dev->phys = ts->phys;
tsc200x-core.c:	error = regulator_enable(ts->vio);
tsc200x-core.c:	error = input_register_device(ts->idev);
tsc200x-core.c:	regulator_disable(ts->vio);
tsc200x-core.c:	regulator_disable(ts->vio);
tsc200x-core.c:	mutex_lock(&ts->mutex);
tsc200x-core.c:	if (!ts->suspended && ts->opened)
tsc200x-core.c:	ts->suspended = true;
tsc200x-core.c:	mutex_unlock(&ts->mutex);
tsc200x-core.c:	mutex_lock(&ts->mutex);
tsc200x-core.c:	if (ts->suspended && ts->opened)
tsc200x-core.c:	ts->suspended = false;
tsc200x-core.c:	mutex_unlock(&ts->mutex);
ucb1400_ts.c:/* Must be called with ts->lock held */
w90p910_ts.c:	struct input_dev *dev = w90p910_ts->input;
w90p910_ts.c:				 __raw_readl(w90p910_ts->ts_reg + 0x0c));
w90p910_ts.c:				 __raw_readl(w90p910_ts->ts_reg + 0x10));
w90p910_ts.c:	__raw_writel(ADC_TSC_X, w90p910_ts->ts_reg + 0x04);
w90p910_ts.c:	ctlreg = __raw_readl(w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(ctlreg, w90p910_ts->ts_reg);
w90p910_ts.c:	w90p910_ts->state = TS_WAIT_X_COORD;
w90p910_ts.c:	__raw_writel(ADC_TSC_Y, w90p910_ts->ts_reg + 0x04);
w90p910_ts.c:	ctlreg = __raw_readl(w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(ctlreg, w90p910_ts->ts_reg);
w90p910_ts.c:	w90p910_ts->state = TS_WAIT_Y_COORD;
w90p910_ts.c:	ctlreg = __raw_readl(w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(ctlreg, w90p910_ts->ts_reg);
w90p910_ts.c:	w90p910_ts->state = TS_WAIT_NEW_PACKET;
w90p910_ts.c:	spin_lock_irqsave(&w90p910_ts->lock, flags);
w90p910_ts.c:	switch (w90p910_ts->state) {
w90p910_ts.c:		del_timer(&w90p910_ts->timer);
w90p910_ts.c:		mod_timer(&w90p910_ts->timer, jiffies + msecs_to_jiffies(100));
w90p910_ts.c:	spin_unlock_irqrestore(&w90p910_ts->lock, flags);
w90p910_ts.c:	spin_lock_irqsave(&w90p910_ts->lock, flags);
w90p910_ts.c:	if (w90p910_ts->state == TS_WAIT_NEW_PACKET &&
w90p910_ts.c:	    !(__raw_readl(w90p910_ts->ts_reg + 0x04) & ADC_DOWN)) {
w90p910_ts.c:	spin_unlock_irqrestore(&w90p910_ts->lock, flags);
w90p910_ts.c:	clk_enable(w90p910_ts->clk);
w90p910_ts.c:	__raw_writel(ADC_RST1, w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(ADC_RST0, w90p910_ts->ts_reg);
w90p910_ts.c:	val = __raw_readl(w90p910_ts->ts_reg + 0x04);
w90p910_ts.c:	__raw_writel(val & TSC_FOURWIRE, w90p910_ts->ts_reg + 0x04);
w90p910_ts.c:	__raw_writel(ADC_DELAY, w90p910_ts->ts_reg + 0x08);
w90p910_ts.c:	w90p910_ts->state = TS_WAIT_NEW_PACKET;
w90p910_ts.c:	val = __raw_readl(w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(val, w90p910_ts->ts_reg);
w90p910_ts.c:	spin_lock_irq(&w90p910_ts->lock);
w90p910_ts.c:	w90p910_ts->state = TS_IDLE;
w90p910_ts.c:	val = __raw_readl(w90p910_ts->ts_reg);
w90p910_ts.c:	__raw_writel(val, w90p910_ts->ts_reg);
w90p910_ts.c:	spin_unlock_irq(&w90p910_ts->lock);
w90p910_ts.c:	del_timer_sync(&w90p910_ts->timer);
w90p910_ts.c:	clk_disable(w90p910_ts->clk);
w90p910_ts.c:	w90p910_ts->input = input_dev;
w90p910_ts.c:	w90p910_ts->state = TS_IDLE;
w90p910_ts.c:	spin_lock_init(&w90p910_ts->lock);
w90p910_ts.c:	setup_timer(&w90p910_ts->timer, w90p910_check_pen_up,
w90p910_ts.c:	w90p910_ts->ts_reg = ioremap(res->start, resource_size(res));
w90p910_ts.c:	if (!w90p910_ts->ts_reg) {
w90p910_ts.c:	w90p910_ts->clk = clk_get(&pdev->dev, NULL);
w90p910_ts.c:	if (IS_ERR(w90p910_ts->clk)) {
w90p910_ts.c:		err = PTR_ERR(w90p910_ts->clk);
w90p910_ts.c:	w90p910_ts->irq_num = platform_get_irq(pdev, 0);
w90p910_ts.c:	if (request_irq(w90p910_ts->irq_num, w90p910_ts_interrupt,
w90p910_ts.c:	err = input_register_device(w90p910_ts->input);
w90p910_ts.c:fail5:	free_irq(w90p910_ts->irq_num, w90p910_ts);
w90p910_ts.c:fail4:	clk_put(w90p910_ts->clk);
w90p910_ts.c:fail3:	iounmap(w90p910_ts->ts_reg);
w90p910_ts.c:	free_irq(w90p910_ts->irq_num, w90p910_ts);
w90p910_ts.c:	del_timer_sync(&w90p910_ts->timer);
w90p910_ts.c:	iounmap(w90p910_ts->ts_reg);
w90p910_ts.c:	clk_put(w90p910_ts->clk);
w90p910_ts.c:	input_unregister_device(w90p910_ts->input);
wm831x-ts.c:	if (wm831x_ts->pen_down) {
wm831x-ts.c:		enable_irq(wm831x_ts->data_irq);
wm831x-ts.c:		dev_dbg(wm831x_ts->wm831x->dev, "IRQ PD->DATA done\n");
wm831x-ts.c:		enable_irq(wm831x_ts->pd_irq);
wm831x-ts.c:		dev_dbg(wm831x_ts->wm831x->dev, "IRQ DATA->PD done\n");
wm831x-ts.c:	struct wm831x *wm831x = wm831x_ts->wm831x;
wm831x-ts.c:	if (wm831x_ts->pressure)
wm831x-ts.c:	wm831x_ts->pen_down = true;
wm831x-ts.c:			wm831x_ts->pen_down = false;
wm831x-ts.c:		input_report_abs(wm831x_ts->input_dev, data_types[i],
wm831x-ts.c:	if (!wm831x_ts->pen_down) {
wm831x-ts.c:		disable_irq_nosync(wm831x_ts->data_irq);
wm831x-ts.c:		if (wm831x_ts->pressure)
wm831x-ts.c:			input_report_abs(wm831x_ts->input_dev,
wm831x-ts.c:		input_report_key(wm831x_ts->input_dev, BTN_TOUCH, 0);
wm831x-ts.c:		schedule_work(&wm831x_ts->pd_data_work);
wm831x-ts.c:		input_report_key(wm831x_ts->input_dev, BTN_TOUCH, 1);
wm831x-ts.c:	input_sync(wm831x_ts->input_dev);
wm831x-ts.c:	struct wm831x *wm831x = wm831x_ts->wm831x;
wm831x-ts.c:	if (wm831x_ts->pen_down)
wm831x-ts.c:	disable_irq_nosync(wm831x_ts->pd_irq);
wm831x-ts.c:	if (wm831x_ts->pressure)
wm831x-ts.c:	wm831x_ts->pen_down = true;
wm831x-ts.c:	schedule_work(&wm831x_ts->pd_data_work);
wm831x-ts.c:	struct wm831x *wm831x = wm831x_ts->wm831x;
wm831x-ts.c:	struct wm831x *wm831x = wm831x_ts->wm831x;
wm831x-ts.c:	synchronize_irq(wm831x_ts->data_irq);
wm831x-ts.c:	synchronize_irq(wm831x_ts->pd_irq);
wm831x-ts.c:	flush_work(&wm831x_ts->pd_data_work);
wm831x-ts.c:	if (wm831x_ts->pen_down) {
wm831x-ts.c:		disable_irq(wm831x_ts->data_irq);
wm831x-ts.c:		enable_irq(wm831x_ts->pd_irq);
wm831x-ts.c:		wm831x_ts->pen_down = false;
wm831x-ts.c:	wm831x_ts->wm831x = wm831x;
wm831x-ts.c:	wm831x_ts->input_dev = input_dev;
wm831x-ts.c:	INIT_WORK(&wm831x_ts->pd_data_work, wm831x_pd_data_work);
wm831x-ts.c:	wm831x_ts->data_irq = wm831x_irq(wm831x,
wm831x-ts.c:		wm831x_ts->data_irq = pdata->data_irq;
wm831x-ts.c:	wm831x_ts->pd_irq = wm831x_irq(wm831x,
wm831x-ts.c:		wm831x_ts->pd_irq = pdata->pd_irq;
wm831x-ts.c:		wm831x_ts->pressure = pdata->pressure;
wm831x-ts.c:		wm831x_ts->pressure = true;
wm831x-ts.c:		wm831x_ts->pressure = false;
wm831x-ts.c:	error = request_threaded_irq(wm831x_ts->data_irq,
wm831x-ts.c:			wm831x_ts->data_irq, error);
wm831x-ts.c:	disable_irq(wm831x_ts->data_irq);
wm831x-ts.c:	error = request_threaded_irq(wm831x_ts->pd_irq,
wm831x-ts.c:			wm831x_ts->pd_irq, error);
wm831x-ts.c:	if (wm831x_ts->pressure)
wm831x-ts.c:	free_irq(wm831x_ts->pd_irq, wm831x_ts);
wm831x-ts.c:	free_irq(wm831x_ts->data_irq, wm831x_ts);
wm831x-ts.c:	free_irq(wm831x_ts->pd_irq, wm831x_ts);
wm831x-ts.c:	free_irq(wm831x_ts->data_irq, wm831x_ts);
wm97xx-core.c:	 * the AUX ADC before we can use sample the AUX inputs->
zet6223.c:	enable_irq(ts->client->irq);
zet6223.c:	disable_irq(ts->client->irq);
zet6223.c:	u8 bufsize = 3 + 4 * ts->fingernum;
zet6223.c:	ret = i2c_master_recv(ts->client, buf, bufsize);
zet6223.c:		dev_err_ratelimited(&ts->client->dev,
zet6223.c:	for (i = 0; i < ts->fingernum; i++) {
zet6223.c:		input_mt_slot(ts->input, i);
zet6223.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);
zet6223.c:		input_event(ts->input, EV_ABS, ABS_MT_POSITION_X,
zet6223.c:		input_event(ts->input, EV_ABS, ABS_MT_POSITION_Y,
zet6223.c:	input_mt_sync_frame(ts->input);
zet6223.c:	input_sync(ts->input);
zet6223.c:	regulator_bulk_disable(ARRAY_SIZE(ts->supplies), ts->supplies);
zet6223.c:	struct device *dev = &ts->client->dev;
zet6223.c:	ts->supplies[0].supply = "vio";
zet6223.c:	ts->supplies[1].supply = "vcc";
zet6223.c:	error = devm_regulator_bulk_get(dev, ARRAY_SIZE(ts->supplies),
zet6223.c:					ts->supplies);
zet6223.c:	error = regulator_bulk_enable(ARRAY_SIZE(ts->supplies), ts->supplies);
zet6223.c:	ret = i2c_master_send(ts->client, &cmd, sizeof(cmd));
zet6223.c:		dev_err(&ts->client->dev,
zet6223.c:	ret = i2c_master_recv(ts->client, buf, sizeof(buf));
zet6223.c:		dev_err(&ts->client->dev,
zet6223.c:	ts->fingernum = buf[15] & 0x7F;
zet6223.c:	if (ts->fingernum > ZET6223_MAX_FINGERS) {
zet6223.c:		dev_warn(&ts->client->dev,
zet6223.c:			 ts->fingernum, ZET6223_MAX_FINGERS);
zet6223.c:		ts->fingernum = ZET6223_MAX_FINGERS;
zet6223.c:	ts->max_x = get_unaligned_le16(&buf[8]);
zet6223.c:	ts->max_y = get_unaligned_le16(&buf[10]);
zet6223.c:	ts->client = client;
zet6223.c:	ts->input = input = devm_input_allocate_device(dev);
zet6223.c:	input_set_abs_params(input, ABS_MT_POSITION_X, 0, ts->max_x, 0, 0);
zet6223.c:	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, ts->max_y, 0, 0);
zet6223.c:	touchscreen_parse_properties(input, true, &ts->prop);
zet6223.c:	error = input_mt_init_slots(input, ts->fingernum,
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	mutex_lock(&ts->access_mutex);
zforce_ts.c:	mutex_unlock(&ts->access_mutex);
zforce_ts.c:	gpiod_set_value_cansleep(ts->gpio_rst, 1);
zforce_ts.c:	gpiod_set_value_cansleep(ts->gpio_rst, 0);
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	ret = mutex_trylock(&ts->command_mutex);
zforce_ts.c:	ts->command_waiting = buf[2];
zforce_ts.c:	mutex_lock(&ts->access_mutex);
zforce_ts.c:	mutex_unlock(&ts->access_mutex);
zforce_ts.c:	if (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0) {
zforce_ts.c:	ret = ts->command_result;
zforce_ts.c:	mutex_unlock(&ts->command_mutex);
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	const struct zforce_ts_platdata *pdata = ts->pdata;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	const struct zforce_ts_platdata *pdata = ts->pdata;
zforce_ts.c:		input_mt_slot(ts->input, point.id - 1);
zforce_ts.c:		input_mt_report_slot_state(ts->input, MT_TOOL_FINGER,
zforce_ts.c:			input_report_abs(ts->input, ABS_MT_POSITION_X,
zforce_ts.c:			input_report_abs(ts->input, ABS_MT_POSITION_Y,
zforce_ts.c:			input_report_abs(ts->input, ABS_MT_TOUCH_MAJOR,
zforce_ts.c:			input_report_abs(ts->input, ABS_MT_TOUCH_MINOR,
zforce_ts.c:			input_report_abs(ts->input, ABS_MT_ORIENTATION,
zforce_ts.c:	input_mt_sync_frame(ts->input);
zforce_ts.c:	input_mt_report_finger_count(ts->input, num);
zforce_ts.c:	input_sync(ts->input);
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	mutex_lock(&ts->access_mutex);
zforce_ts.c:	mutex_unlock(&ts->access_mutex);
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	if (ts->command_waiting == cmd) {
zforce_ts.c:		ts->command_result = result;
zforce_ts.c:		complete(&ts->command_done);
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	if (ts->suspended && device_may_wakeup(&client->dev))
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	if (ts->suspended) {
zforce_ts.c:	if (!ts->suspending && device_may_wakeup(&client->dev))
zforce_ts.c:			if (ts->suspending && device_may_wakeup(&client->dev))
zforce_ts.c:			ts->boot_complete = payload[RESPONSE_DATA];
zforce_ts.c:			ts->version_major = (payload[RESPONSE_DATA + 1] << 8) |
zforce_ts.c:			ts->version_minor = (payload[RESPONSE_DATA + 3] << 8) |
zforce_ts.c:			ts->version_build = (payload[RESPONSE_DATA + 5] << 8) |
zforce_ts.c:			ts->version_rev   = (payload[RESPONSE_DATA + 7] << 8) |
zforce_ts.c:			dev_dbg(&ts->client->dev,
zforce_ts.c:				ts->version_major, ts->version_minor,
zforce_ts.c:				ts->version_build, ts->version_rev);
zforce_ts.c:			dev_err(&ts->client->dev, "invalid command: 0x%x\n",
zforce_ts.c:			dev_err(&ts->client->dev,
zforce_ts.c:	} while (gpiod_get_value_cansleep(ts->gpio_int));
zforce_ts.c:	if (!ts->suspending && device_may_wakeup(&client->dev))
zforce_ts.c:	struct i2c_client *client = ts->client;
zforce_ts.c:	struct input_dev *input = ts->input;
zforce_ts.c:	ts->suspending = true;
zforce_ts.c:	ts->suspended = true;
zforce_ts.c:	ts->suspending = false;
zforce_ts.c:	struct input_dev *input = ts->input;
zforce_ts.c:	ts->suspended = false;
zforce_ts.c:	if (!IS_ERR(ts->reg_vdd))
zforce_ts.c:		regulator_disable(ts->reg_vdd);
zforce_ts.c:	ts->gpio_rst = devm_gpiod_get_optional(&client->dev, "reset",
zforce_ts.c:	if (IS_ERR(ts->gpio_rst)) {
zforce_ts.c:		ret = PTR_ERR(ts->gpio_rst);
zforce_ts.c:	if (ts->gpio_rst) {
zforce_ts.c:		ts->gpio_int = devm_gpiod_get_optional(&client->dev, "irq",
zforce_ts.c:		if (IS_ERR(ts->gpio_int)) {
zforce_ts.c:			ret = PTR_ERR(ts->gpio_int);
zforce_ts.c:		ts->gpio_int = devm_gpiod_get_index(&client->dev, NULL, 0,
zforce_ts.c:		if (IS_ERR(ts->gpio_int)) {
zforce_ts.c:			ret = PTR_ERR(ts->gpio_int);
zforce_ts.c:		ts->gpio_rst = devm_gpiod_get_index(&client->dev, NULL, 1,
zforce_ts.c:		if (IS_ERR(ts->gpio_rst)) {
zforce_ts.c:			ret = PTR_ERR(ts->gpio_rst);
zforce_ts.c:	ts->reg_vdd = devm_regulator_get_optional(&client->dev, "vdd");
zforce_ts.c:	if (IS_ERR(ts->reg_vdd)) {
zforce_ts.c:		ret = PTR_ERR(ts->reg_vdd);
zforce_ts.c:		ret = regulator_enable(ts->reg_vdd);
zforce_ts.c:		if (!IS_ERR(ts->reg_vdd))
zforce_ts.c:			regulator_disable(ts->reg_vdd);
zforce_ts.c:	snprintf(ts->phys, sizeof(ts->phys),
zforce_ts.c:	mutex_init(&ts->access_mutex);
zforce_ts.c:	mutex_init(&ts->command_mutex);
zforce_ts.c:	ts->pdata = pdata;
zforce_ts.c:	ts->client = client;
zforce_ts.c:	ts->input = input_dev;
zforce_ts.c:	input_dev->phys = ts->phys;
zforce_ts.c:	input_set_drvdata(ts->input, ts);
zforce_ts.c:	init_completion(&ts->command_done);
zforce_ts.c:	ts->command_waiting = NOTIFICATION_BOOTCOMPLETE;
zforce_ts.c:	if (wait_for_completion_timeout(&ts->command_done, WAIT_TIMEOUT) == 0)
